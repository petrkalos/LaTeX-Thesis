\chapter{Υλοποίηση και Βελτιστοποίηση}
\label{chapter:chap4}

Αυτό το κεφάλαιο περιγράφει την διαδικασία υλοποίησης και βελτιστοποίησης του αλγορίθμου για την διόρθωση της παραμόρφωσης που προκαλείται από ευρυγώνιους φακούς στον επεξεργαστή \textsl{Cell}.

\section{Στάδια Υλοποίησης}
\label{section:sect41}
\indent
Το πρώτο στάδιο στην διαδικασία υλοποίησης του αλγορίθμου είναι η εφαρμογή μετασχηματισμών υψηλού επιπέδου για την εκμετάλλευση του παραλληλισμού που υπάρχει στην εφαρμογή. Μία πολύ σημαντική παρατήρηση από την ανάλυση του αλγορίθμου στο Κεφάλαιο~\ref{chapter:chap2} είναι ότι οι συντεταγμένες των \textsl{pixels} στις μη ακέραιες θέσεις ακολουθούν ένα αρκετά περίπλοκο και μη γραμμικό πρότυπο (Σχήμα~\ref{figure:fig25}). Η ακριβής μορφή της τροχιάς εξαρτάται από αρκετούς παράγοντες συμπεριλαμβανομένου του \ac{FoV}, της θέσης του \textsl{pixel} και των παραμέτρων που μοντελοποιούν την παραμόρφωση που εισάγεται από τον εκάστοτε φακό που χρησιμοποιείται. Η μορφή της τροχιάς δεν εξαρτάται από την εικόνα που ο αλγόριθμος λαμβάνει ως είσοδο.\newline \indent 
Επομένως, δοθέντων των διαφόρων παραμέτρων και της \textsl{περιοχής ενδιαφέροντος} (\ac{ROI}) όπου ο χρήστης επιθυμεί την διόρθωση, είναι δυνατός ο εκ των προτέρων υπολογισμός της τροχιάς που ακολουθείται. Όμως, το αρκετά περίπλοκο πρότυπο προσπέλασης στην μνήμη, οι περιορισμοί ευθυγράμμισης της προσπέλασης στην μνήμη που επιβάλλει ο επεξεργαστής \textsl{Cell} και η μικρή χωρητικότητα της \ac{LS} καθιστούν την εκ των προτέρων μεταφορά των δεδομένων, γνωστή και ως \textsl{prefetching}, αδύνατη.\newline \indent
Αν και δεν είναι δυνατή η εφαρμογή \textsl{prefetching}, ο αλγόριθμος διόρθωσης εμφανίζει μεγάλο βαθμό επαναχρησιμοποίησης των δεδομένων. Δεδομένα της \(4x4\) γειτονιάς που χρησιμοποιήθηκαν για την παρεμβολή της τιμής ενός \textsl{pixel}, χρησιμοποιούνται και για την παρεμβολή γειτονικών \textsl{pixels}. Ενδεικτικό παράδειγμα αποτελούν τα \textsl{pixels} στις θέσεις \((x-1, y)\) και \((x,y)\) του σχήματος~\ref{figure:fig25} όπου χρησιμοποιείται η ίδια γειτονιά για την εφαρμογή του σχήματος παρεμβολής. Αυτού του είδους η επαναχρησιμοποίηση μεγιστοποιείται με χρήση του \textsl{2-D tiling} σε κάθε \textsl{frame}.\newline \indent 
Η τεχνική του \textsl{tiling} εκμεταλλεύεται την \textsl{χωρική τοπικότητα} (\textsl{spatial locality}) και χρησιμοποιείται από μεταγλωττιστές βελτιστοποίησης (\textsl{optimizing compilers}) για την αύξηση του ποσοστού επιτυχίας στις προσβάσεις στην μνήμη \textsl{cache}. Κάθε \textsl{frame} τεμαχίζεται σε \textsl{blocks} ίσου μεγέθους και ο αλγόριθμος διόρθωσης εφαρμόζεται διαδοχικά στα \textsl{pixels} του κάθε \textsl{block}. Κατ' αυτό τον τρόπο επιτυγχάνεται η βελτιστοποίηση των υπολογισμών καθώς υπάρχει επαναχρησιμοποίηση των δεδομένων σε επίπεδο \textsl{block}.
\begin{figure}
\centering
\includegraphics[width=2.5in, height=1.2in]{Chapter4/figures/figure1.eps}
\caption{Ένα \textsl{tile} από την εικόνα εισόδου και το αντίστοιχο διορθωμένο \textsl{block}.}
\label{figure:fig41}
\end{figure}
Το σχήμα~\ref{figure:fig41} παρουσιάζει ένα από τα \textsl{tiles} του διορθωμένου \textsl{frame}, όπου το \textsl{frame} εισόδου είναι αυτό που παρουσιάζεται στο σχήμα~\ref{figure:fig24}, και το αντίστοιχο \textsl{tile} της παραμορφωμένης εικόνας (παρουσιάζεται με κόκκινο περίγραμμα) που απαιτείται για την εφαρμογή του σχήματος παρεμβολής ώστε να παραχθούν τα \textsl{pixels} του διορθωμένου \textsl{tile}. Όπως παρατηρούμε, γειτονικά \textsl{tiles} θα εμφανίζουν κάποια επικάλυψη στον χώρο των ευρυγώνιων φακών λόγω της κύρτωσης που εμφανίζεται. Αυτή η επικάλυψη έχει ως αποτέλεσμα τα \textsl{pixels} που βρίσκονται κοντά στις ακμές να μεταφέρονται περισσότερες από μία φορές από την κύρια μνήμη. Το επιπλέον κόστος για επικοινωνία αποτελεί και το μόνο μειονέκτημα της εφαρμογής του \textsl{tiling} στον αλγόριθμο.\newline \indent
Η εικόνα που χρησιμοποιήθηκε για όλες τις εκτελέσεις και τις διάφορες προσομοιώσεις της εφαρμογής, όπως παρουσιάζεται στο σχήμα~\ref{figure:fig21}, ακολουθεί το \textsl{format} \textsl{RGB} και έχει διαστάσεις \(2592x1944\). Τα στάδια της αντίστροφης απεικόνισης, της παρεμβολής και του βαθυπερατού φίλτρου εφαρμόζονται σε μία περιοχή διαστάσεων \(1280x960\), καθώς αυτό είναι το μέγεθος της \ac{ROI}. Έπειτα, η εικόνα κλιμακώνεται προς τα κάτω, σε μία εικόνα ανάλυσης \textsl{VGA}.\newline \indent
Ο χρόνος εκτέλεσης του αλγορίθμου αξιολογήθηκε για τιμές της παραμέτρου \ac{FoV} από \(1.0^{o}\) έως \(60.0^{o}\) και για όλες τις πιθανές \ac{ROI} της εικόνας αλλά δεν παρουσιάστηκε κάποια μεταβολή. Αυτό ήταν αναμενόμενο καθώς το μέγεθος και η ανάλυση της εικόνας εξόδου είναι καθορισμένα και ανεξάρτητα από άλλες παραμέτρους του αλγορίθμου. Επίσης, το πλήθος των υπολογισμών που εκτελούνται για κάθε \textsl{pixel} της εικόνας εξόδου είναι σταθερό και δεν εξαρτάται από τις παραμέτρους και την εικόνα εισόδου. Βάσει αυτών, στις διάφορες εκτελέσεις του αλγορίθμου χρησιμοποιήθηκε η τιμή \ac{FoV} = \(40.0^{o}\).\newline \indent
Το επόμενο βήμα στην διαδικασία υλοποίησης του αλγορίθμου είναι η εύρεση του παραλληλισμού σε υψηλό επίπεδο ώστε να είναι δυνατή η εκμετάλλευση των διαθέσιμων επεξεργαστών. Μετά την εφαρμογή του \textsl{tiling}, τα δύο εμφανή είδη παραλληλισμού είναι ο παραλληλισμός μεταξύ διαδοχικών \textsl{frames} και ο παραλληλισμός μεταξύ των \textsl{blocks} ενός \textsl{frame} καθώς δεν εμφανίζονται εξαρτήσεις ούτε μεταξύ των \textsl{frames} αλλά ούτε και μεταξύ των \textsl{blocks}. Για την εκμετάλλευση του παραλληλισμού μεταξύ \textsl{frames}, σε κάθε επεξεργαστή ανατίθεται ένα \textsl{frame} προς διόρθωση. Όμως, το μέγεθος του \ac{ROI} (\(1280x960\)) και το περιορισμένο μέγεθος της \ac{LS} δεν επιτρέπουν την αποθήκευση των απαιτούμενων \textsl{pixels} για την διόρθωση στα \acp{SPE}. Έτσι, καταλήγουμε στην εκμετάλλευση του παραλληλισμού που εμφανίζεται εντός ενός \textsl{frame}.\newline \indent
Έπειτα, ακολουθεί το στάδιο του τεμαχισμού και της αντιστοίχισης όπου γίνεται ο διαμερισμός του προβλήματος σε επιμέρους τμήματα και η αντιστοίχιση εργασιών στους διαθέσιμους επεξεργαστές, με έμφαση στην ταυτόχρονη εργασία και στο ελάχιστο επικοινωνιακό κόστος. Το σχήμα τεμαχισμού που χρησιμοποιήθηκε είναι το \textsl{data-cyclic}, ή \textsl{block-cyclic}, σχήμα όπου κάθε επεξεργαστής λαμβάνει με κυκλικό τρόπο ένα \textsl{tile} από την κύρια μνήμη, εκτελεί την απαραίτητη επεξεργασία και αποστέλλει στην κύρια μνήμη το αντίστοιχο διορθωμένο \textsl{tile} της εικόνας εξόδου.\newline \indent
Η τελευταία σχεδιαστική απόφαση που πρέπει να ληφθεί για την υλοποίηση του αλγορίθμου είναι η ακρίβεια στους διάφορους υπολογισμούς που εκτελούνται. Ο αλγόριθμος εμπεριέχει αρκετές πράξεις αριθμών κινητής υποδιαστολής σε όλα τα στάδια της διόρθωσης. Επομένως, η ακρίβεια που χρησιμοποιείται είναι πολύ σημαντική για το τελικό αποτέλεσμα. Ο αλγόριθμος εκτελέστηκε τόσο χρησιμοποιώντας αριθμούς κινητής υποδιαστολής διπλής ακρίβειας όσο και αριθμούς κινητής υποδιαστολής απλής ακρίβειας. Για την αξιολόγηση των αποτελεσμάτων χρησιμοποιήθηκε ο λόγος \ac{PSNR} ώστε να συγκριθούν οι παραγόμενες εικόνες. Όπως παρατηρήθηκε, οι εικόνες που παρήχθησαν με χρήση απλής ακρίβειας ήταν όμοιες σε ποσοστό \(99.6\%\) με τις αντίστοιχες που παρήχθησαν με χρήση διπλής ακρίβειας. Δεδομένης και της περιορισμένης αποδοτικότητας των \acp{SPE} στις πράξεις κινητής υποδιαστολής διπλής ακρίβειας, οι πράξεις που χρησιμοποιούνται σε όλες τις πράξεις αριθμών κινητής υποδιαστολής είναι πράξεις απλής ακρίβειας.\newline \indent
Το υπόλοιπο αυτής της ενότητας περιγράφει την διαδικασία υλοποίησης του αλγορίθμου σε έναν επεξεργαστή \textsl{Intel x86} και στον επεξεργαστή \ac{CBEA}.

\subsection[4.1.1 Υλοποίηση του αλγορίθμου σε αρχιτεκτονική Intel x86]{Υλοποίηση του αλγορίθμου σε αρχιτεκτονική Intel x86}
\label{subsection:sub411}
\indent
Ο \textsl{baseline}\footnote{\small Ο \textsl{baseline} κώδικας είναι ο κώδικας που περιγράφει την βασική λειτουργικότητα της εφαρμογής όπου δεν έχει εφαρμοσθεί κάποια βελτιστοποίηση χαμηλού επιπέδου.} κώδικας που χρησιμοποιήθηκε για την αρχική υλοποίηση του αλγορίθμου είναι αυτός που χρησιμοποιείται και στην εργασία που περιγράφεται στο \cite{BellasFCCM} όπου παρουσιάζεται η υλοποίηση του αλγορίθμου σε μία \ac{FPGA}.\newline \indent
Για να αξιολογηθεί κατά πόσο είναι δυνατή υλοποίηση του αλγορίθμου για την επίτευξη της διόρθωσης παραμόρφωσης σε πραγματικό χρόνο, δηλαδή διόρθωση \(25-30\) \textsl{frames} ανά δευτερόλεπτο, με έναν συμβατικό επεξεργαστή γενικού σκοπού, υλοποιήθηκε και εκτελέστηκε μία παράλληλη, βελτιστοποιημένη έκδοση του αλγορίθμου σε ένα σύστημα που εμπεριέχει έναν επεξεργαστή \textsl{Intel Core2 Duo Τ7500} με συχνότητα λειτουργίας ίση με \(2.2\ GHz\). Το σύστημα ενσωματώνει μνήμη \textsl{RAM} με μέγεθος ίσο με \(2\ GB\) και χρησιμοποιείται το λειτουργικό \textsl{Linux} (διανομή λειτουργικού \textsl{OpenSUSE 10.3}, με τον πυρήνα \(2.6.22\)). Για την μεταγλώττιση του κώδικα της εφαρμογής χρησιμοποιήθηκε τόσο ο μεταγλωττιστής \textsl{icc} από το \textsl{Intel compiler suite} \cite{intelcompilersuite} όσο και ο μεταγλωττιστής \textsl{gcc}. Για την παραγωγή του τελικού εκτελέσιμου σε κάθε μεταγλωττιστή, χρησιμοποιήθηκαν οι επιλογές που οδηγούσαν στο εκτελέσιμο με τον μικρότερο χρόνο εκτέλεσης. Η επίδοση των εκτελέσιμων που παρήχθησαν με χρήση του \textsl{icc} ήταν καλύτερη, οπότε παρουσιάζονται μόνο οι χρόνοι εκτέλεσης αυτών.\newline \indent
Ο κώδικας για τον επεξεργαστή παραλληλοποιήθηκε χρησιμοποιώντας την βιβλιοθήκη \textsl{OpenMP}. Κάθε \textsl{tile} της εικόνας εξόδου παράγεται ανεξάρτητα, ενδεχομένως από ένα διαφορετικό πλαίσιο εκτέλεσης του επεξεργαστή. Εκτός από την εφαρμογή του \textsl{tiling} για την εικόνα εισόδου και την εικόνα εξόδου, εφαρμόσθηκαν όλες οι δυνατές βελτιστοποιήσεις που περιγράφονται στην ενότητα~\ref{section:sect42} και πιο συγκεκριμένα η εφαρμογή της μη αυτόματης διανυσματοποίησης (\textsl{vectorization}) των υπολογισμών χρησιμοποιώντας την αρχιτεκτονική συνόλου εντολών \ac{SSE} (\textsl{SSE ISA}) \cite{intelssedevman} και το ξεδίπλωμα βρόχου. Συν τοις άλλοις, καθώς και η αρχιτεκτονική συνόλου εντολών \ac{SSE} παρουσιάζει κάποιους περιορισμούς ευθυγράμμισης, δόθηκε αρκετή προσοχή στον χειρισμό των φορτώσεων μη ευθυγραμμισμένων δεδομένων σε διανυσματικούς καταχωρητές.\newline \indent
Για την ανάλυση του χρόνου εκτέλεσης της εφαρμογής χρησιμοποιήθηκε το λογισμικό \textsl{Intel VTune Performance Analyzer for Linux, 9.1} \cite{intelvtune}. Η εφαρμογή επεξεργάζεται \(2.38\) \ac{fps} εάν χρησιμοποιηθεί ένα νήμα, ενώ είναι δυνατή η επεξεργασία \(4.17\) \textsl{frames} το δευτερόλεπτο εάν χρησιμοποιηθούν και τα δύο διαθέσιμα νήματα. Τα αποτελέσματα αυτά αποτελούν το κίνητρο για την χρήση ενός μη συμβατικού επεξεργαστή υψηλής απόδοσης, όπως ο επεξεργαστής \ac{CBEA}, για την επίτευξη της επιθυμητής απόδοσης.\newline \indent

\subsection[4.1.2 Υλοποίηση του αλγορίθμου στον επεξεργαστή Cell Broadband Engine]{Υλοποίηση του αλγορίθμου στον επεξεργαστή Cell Broadband Engine}
\label{subsection:sub412}
\indent
Για την πειραματική αξιολόγηση της εφαρμογής στον επεξεργαστή \ac{CBEA} χρησιμοποιήθηκε ένα \textsl{PlayStation3} το οποίο ενσωματώνει έναν επεξεργαστή \textsl{Cell}, όπου είναι διαθέσιμα μόνο τα \(6\) από τα \(8\) \acp{SPE}. Από τα υπόλοιπα \(2\) \acp{SPE}, το ένα χρησιμοποιείται ως πλεονασματικό για την αύξηση του \textsl{yield} ενώ το άλλο χρησιμοποιείται από το λειτουργικό σύστημα για λόγους ασφαλείας \cite{wikipediaps3} (χρησιμοποιείται ως ο \textsl{hypervisor} όπου εκτελείται το εναλλακτικό λειτουργικό σύστημα). Το λειτουργικό που χρησιμοποιείται είναι η διανομή \textsl{Yellow Dog Linux} με τον πυρήνα \(2.6.23\). Όπως προαναφέρθηκε, το λειτουργικό και οι εφαρμογές ελέγχονται από τον \textsl{hypervisor} του συστήματος, οπότε δεν είναι δυνατή η πρόσβαση στους \textsl{hardware performance counters} που διαθέτει ο επεξεργαστής.\newline \indent 
Για την λήψη πιο λεπτομερών αποτελεσμάτων και την αξιολόγηση της εκτέλεσης της εφαρμογής για \(8\) \acp{SPE} χρησιμοποιήθηκε ο προσομοιωτής \textsl{IBM Full-System Simulator}, ο οποίος παρέχεται με το \textsl{Cell BE SDK}. Η έκδοση του προσομοιωτή που χρησιμοποιήθηκε είναι η έκδοση \(3.1\), η οποία εκτελείται στο λειτουργικό \textsl{Fedora Linux 7}. Αυτή η έκδοση του προσομοιωτή είναι ακριβής σε επίπεδο κύκλου ρολογιού (\textsl{cycle-accurate}) για όλα τα στοιχεία του συστήματος, στοιχείο που επιτρέπει την λήψη αρκετά ακριβών μετρήσεων για την εκτέλεση της εφαρμογής. Για την μεταγλώττιση του κώδικα χρησιμοποιήθηκαν οι μεταγλωττιστές \textsl{gcc} (έκδοση \(4.2.1\)) και \textsl{xlc} (έκδοση \(9.0\)), με επιλογές μεταγλώττισης εκείνες που οδηγούσαν στην παραγωγή του εκτελέσιμου με τον πιο μικρό χρόνο εκτέλεσης. Η απόδοση των εκτελέσιμων που παρήχθησαν με τον \textsl{gcc} ήταν καλύτερη, οπότε παρουσιάζονται μόνο οι χρόνοι εκτέλεσης αυτών.\newline \indent

\subsubsection{Εκτέλεση του αλγορίθμου στο PPE}
\label{subsubsection:subsub4121}
\indent
Μετά την εφαρμογή της τεχνικής του \textsl{tiling} ώστε οι υπολογισμοί να πραγματοποιούνται σε \textsl{blocks}, το επόμενο στάδιο για την υλοποίηση του αλγορίθμου στον επεξεργαστή \ac{CBEA} είναι η διαδικασία του \textsl{profiling} ώστε να βρεθούν οι υπολογιστικοί πυρήνες όπου το πρόγραμμα δαπανά το μεγαλύτερο μέρος του χρόνου εκτέλεσης. Από αυτή την διαδικασία θα προκύψουν οι πιο χρονοβόροι υπολογιστικοί πυρήνες, οι οποίοι εν συνεχεία θα ανατεθούν στα \acp{SPE}, ώστε να είναι δυνατή η εκμετάλλευση των δυνατοτήτων αυτών. Για την διαδικασία του \textsl{profiling} στο \ac{PPE} χρησιμοποιήθηκε το πρόγραμμα \textsl{GProf} \cite{gprof}. Για τις απαραίτητες μετρήσεις εκτελέσθηκε ο κώδικας της εφαρμογής με ένα νήμα τόσο στον επεξεργαστή \textsl{Core2 Duo} όσο και στο \ac{PPE} ενώ δεν χρησιμοποιήθηκαν οι επεκτάσεις \textsl{AltiVec} για τον κώδικα στο \ac{PPE}. Το σχήμα~\ref{figure:fig42} παρουσιάζει την αναλυτική παράθεση του συνολικού χρόνου και των χρόνων εκτέλεσης των υπολογιστικά πολυπλοκότερων πυρήνων της εφαρμογής για τους δύο επεξεργαστές.
\begin{figure}
\centering
\includegraphics[width=5in, height=2.5in]{Chapter4/figures/figure2.eps}
\caption{Ο χρόνος εκτέλεσης της εφαρμογής στο \textsl{PPE} (με χρήση του \textsl{gcc}) και στον \textsl{Core2 Duo} (με χρήση του \textsl{icc}).}
\label{figure:fig42}
\end{figure}
\newline \indent
Όπως παρατηρούμε, οι υπολογιστικά πολυπλοκότεροι πυρήνες της εφαρμογής και για τους δύο επεξεργαστές είναι οι συναρτήσεις \textsl{Inverse Mapping}, \textsl{Bicubic Interpolation} και \textsl{Low-Pass Filter} που υλοποιούν την \textsl{αντίστροφη απεικόνιση}, την \textsl{παρεμβολή} και το \textsl{βαθυπερατό φίλτρο} αντίστοιχα. Η συνάρτηση που υλοποιεί το σχήμα παρεμβολής είναι ο πιο πολύπλοκος υπολογιστικός πυρήνας με συνεισφορά στον χρόνο εκτέλεσης της εφαρμογής μεγαλύτερη του \(60\%\) και για τους δύο επεξεργαστές. Η συνάρτηση που υλοποιεί την \textsl{αντίστροφη απεικόνιση} έχει μικρή συνεισφορά και αυτό οφείλεται στις αρκετά αποδοτικές μονάδες που εκτελούν πράξεις αριθμών κινητής υποδιαστολής που εμπεριέχονται στο \ac{PPE} και στον \textsl{Core2 Duo}. Επίσης, ο χρόνος εκτέλεσης της εφαρμογής στο \ac{PPE} είναι μεγαλύτερος από τον χρόνο εκτέλεσης στον \textsl{Core2 Duo}, οπότε η διόρθωση σε πραγματικό χρόνο δεν είναι εφικτή σε περίπτωση που ο αλγόριθμος εκτελείται εξολοκλήρου στο \ac{PPE}, δηλαδή χωρίς την χρήση των διαθέσιμων \acp{SPE}.\newline \indent
Εδώ θα πρέπει να αναφερθεί ότι η συνάρτηση \textsl{Inverse Mapping} πρέπει να καλείται μόνο σε περίπτωση που οι παράμετροι \ac{FoV} ή \ac{ROI} μεταβάλλονται. Για ένα ρεαλιστικό σενάριο χρήσης του αλγορίθμου, η συχνότητα μεταβολής αυτών των παραμέτρων δεν αναμένεται να είναι μεγάλη. Τα αποτελέσματα του σχήματος~\ref{figure:fig42} υποθέτουν την εκτέλεση του \textsl{Inverse Mapping} για κάθε \textsl{frame} στο οποίο εκτελείται η διόρθωση. Στο Κεφάλαιο~\ref{chapter:chap5} αξιολογείται η περίπτωση όπου η διαδικασία του \textsl{Inverse Mapping} εκτελείται μόνο μία φορά, οι συντεταγμένες αποθηκεύονται στην κύρια μνήμη και μεταφέρονται στα \acp{SPE} για την διόρθωση κάθε \textsl{tile}.

\subsubsection{Εκμετάλλευση του παραλληλισμού σε επίπεδο tile}
\label{subsubsection:subsub4122}
\indent
Όπως προέκυψε από το σχήμα~\ref{figure:fig42}, οι συναρτήσεις που είναι υπεύθυνες για την πλειονότητα του χρόνου εκτέλεσης του αλγορίθμου είναι οι συναρτήσεις \textsl{Inverse Mapping}, \textsl{Bicubic Interpolation} και \textsl{Low-Pass Filter}. Αυτές είναι και οι συναρτήσεις που θα υλοποιηθούν στα \acp{SPE}. Το \ac{PPE} εκτελεί τον απαραίτητο κώδικα για την αρχικοποίηση του συστήματος, όπου συμπεριλαμβάνεται η φόρτωση της εικόνας εισόδου, και δημιουργεί τα απαραίτητα νήματα για την εκτέλεση του αντίστοιχου κώδικα στα \acp{SPE}.\newline \indent
Το σχήμα διαμοιρασμού των \textsl{tiles} στα διαθέσιμα \acp{SPE} είναι το σχήμα \textsl{block-cyclic} που περιγράφεται στην ενότητα~\ref{section:sect41}. Αυτό το σχήμα τεμαχισμού επιτρέπει στο κάθε \ac{SPE} να επεξεργάζεται τα δεδομένα ανεξάρτητα τόσο από τα υπόλοιπα \acp{SPE} όσο και από το \ac{PPE}. Ο μόνος συγχρονισμός που απαιτείται είναι αυτός στο τέλος της επεξεργασίας του κάθε \textsl{frame}. Το μέγεθος του \textsl{tile} ορίζεται σε \(256\) στήλες και \(48\) γραμμές και αυτό το μέγεθος χρησιμοποιείται για όλες τις εκτελέσεις της εφαρμογής. Στο Κεφάλαιο~\ref{chapter:chap5} εξετάζονται διάφορα μεγέθη των \textsl{tiles} για την αξιολόγηση του μεγέθους του \textsl{tile} στον χρόνο εκτέλεσης του αλγορίθμου.\newline \indent
Για την μεταφορά των \textsl{pixels} που απαρτίζουν κάθε \textsl{tile} από την κύρια μνήμη στην \ac{LS} του κάθε \ac{SPE}, χρησιμοποιείται ο μηχανισμός των ασύγχρονων αιτήσεων \ac{DMA}, όπως αυτός περιγράφηκε στην ενότητα~\ref{subsubsection:subsub3322}. Κάθε \ac{SPE} αρχικοποιεί τις απαραίτητες αιτήσεις για την μεταφορά των δεδομένων μεταξύ της κύριας και της τοπικής μνήμης. Η επιλογή της αρχικοποίησης των αιτήσεων \ac{DMA} από τα \acp{SPE} είναι επιβεβλημένη καθώς σε περίπτωση που οι αιτήσεις αρχικοποιούνταν από το \ac{PPE}, το \ac{PPE} θα αποτελούσε πιθανό σημείου συνωστισμού, λόγω του μεγάλου αριθμού αιτήσεων \ac{DMA} που απαιτούνται για την μεταφορά των δεδομένων.\newline \indent
Όσον αφορά στην μορφή των δεδομένων που μεταφέρονται, αυτά αποτελούν μεταβλητές τύπου \textsl{unsigned char}. Αυτή η μορφή των δεδομένων συντελεί στην ταχύτερη μεταφορά των δεδομένων λόγω του μικρού μεγέθους. Όμως, για την εκτέλεση των μετέπειτα πράξεων, όπως για παράδειγμα το σχήμα παρεμβολής, είναι απαραίτητη η μετατροπή των δεδομένων σε αριθμούς κινητής υποδιαστολής απλής ακρίβειας.\newline
\indent
Το σχήμα~\ref{figure:fig43} παρουσιάζει τον χρόνο εκτέλεσης της αρχικής έκδοσης του κώδικα της εφαρμογής, όπου δεν χρησιμοποιείται η τεχνική του \textsl{double-buffering}, και της τελικής έκδοσης αυτού, όπου έχουν εφαρμοσθεί όλες οι βελτιστοποιήσεις. Το διάγραμμα είναι σε λογαριθμική κλίμακα και οι μετρήσεις για \(7\) και \(8\) \acp{SPE} αποκτήθηκαν με χρήση του προσομοιωτή. Οι μετρήσεις για \(1-6\) \acp{SPE} στο \textsl{PlayStation 3} συμπίπτουν με τις μετρήσεις στον προσομοιωτή και αυτό μας επιτρέπει να χρησιμοποιήσουμε και τις μετρήσεις για \(7\) και \(8\) \acp{SPE} ως ακριβείς μετρήσεις για τον χρόνο εκτέλεσης της εφαρμογής.\newline \indent 
Η εφαρμογή εκτελέσθηκε για \(1\) έως \(8\) \acp{SPE} και παρατηρήθηκε ότι η αύξηση του αριθμού των \acp{SPE} που χρησιμοποιούνται για την επεξεργασία αποφέρει μεγάλα οφέλη στην απόδοση της εφαρμογής. Αυτό οφείλεται κυρίως στον μεγάλο βαθμό παραλληλισμού που παρουσιάζει η εφαρμογή. Στην πραγματικότητα, ο χρόνος εκτέλεσης μειώνεται γραμμικά με την αύξηση του αριθμού των \acp{SPE} από \(4.93\ secs/frame\) όταν χρησιμοποιείται \(1\) \ac{SPE} σε \(0.62\ secs/frame\) όταν χρησιμοποιούνται \(8\) \acp{SPE}. Το \textsl{speedup} που επιτυγχάνεται είναι σχεδόν τέλειο (\(\simeq 8\)) και αυτό δικαιολογεί την επιλογή του σχήματος τεμαχισμού που χρησιμοποιείται. Από το σχήμα~\ref{figure:fig43} παρατηρούμε επίσης ότι η αρχιτεκτονική των \acp{SPE} δεν είναι βελτιστοποιημένη για την εκτέλεση κώδικα που αποτελείται από βαθμωτές πράξεις. Η αρχιτεκτονική του \ac{PPE} είναι πιο αποδοτική στην εκτέλεση βαθμωτών πράξεων: \(1\) νήμα εκτέλεσης στο \ac{PPE} επεξεργάζεται ένα \textsl{frame} σε \(1.8\ secs\) ενώ ένα \ac{SPE} επεξεργάζεται \(1\) \textsl{frame} σε \(4.93\ secs\). Σε αυτό συντελεί και ο χρόνος που το \ac{SPE} δαπανά αναμένοντας αδρανές για την ολοκλήρωση των μεταφορών.\newline \indent
Όσον αφορά στον χρόνο εκτέλεσης του κάθε υπολογιστικού πυρήνα στα \acp{SPE}, αυτός παρουσιάζεται αναλυτικά στο σχήμα~\ref{figure:fig44}. Από το σχήμα παρατηρούμε ότι ο υπολογιστικά πολυπλοκότερος πυρήνας είναι η διαδικασία του \textsl{Inverse Mapping} και αυτό οφείλεται στις πολύπλοκες τριγωνομετρικές συναρτήσεις που χρησιμοποιούνται για την \textsl{αντίστροφη απεικόνιση}. Παρά την αποτελεσματικότητα στην εκτέλεση των συναρτήσεων της βιβλιοθήκης \textsl{SIMD Math Library} \cite{simdmath}, δεν ήταν δυνατή η περαιτέρω βελτίωση του χρόνου εκτέλεσης της εφαρμογής.
\begin{figure}
\centering
\includegraphics[width=5in, height=2.5in]{Chapter4/figures/figure3.eps}
\caption{Ο χρόνος εκτέλεσης της αρχικής και της τελικής έκδοσης του κώδικα της εφαρμογής συναρτήσει του αριθμού των \textsl{SPEs}.}
\label{figure:fig43}
\end{figure}
\begin{figure}
\centering
\includegraphics[width=5in, height=2.5in]{Chapter4/figures/figure4.eps}
\caption{Αναλυτική παράθεση του χρόνου εκτέλεσης κάθε υπολογιστικού πυρήνα συναρτήσει του αριθμού των \textsl{SPEs}.}
\label{figure:fig44}
\end{figure}
\indent

\section{Στάδια Βελτιστοποίησης}
\label{section:sect42}
\indent
Από την ανάλυση στην ενότητα~\ref{section:sect41} είναι κατανοητό ότι δεν είναι δυνατή η επίτευξη διόρθωσης σε πραγματικό χρόνο χωρίς την εφαρμογή κάποιων μετασχηματισμών βελτιστοποίησης, οι οποίοι θα έχουν ως αποτέλεσμα την μείωση του χρόνου εκτέλεσης της εφαρμογής. Η παρούσα ενότητα αναλύει όλους τους μετασχηματισμούς που πραγματοποιήθηκαν στον πηγαίο κώδικα της εφαρμογής.

\subsection[4.2.1 DMA Double Buffering]{DMA Double Buffering}
\label{subsection:sub421}
\indent
Στην αρχική έκδοση του πηγαίου κώδικα του αλγορίθμου, η μεταφορά των δεδομένων δεν πραγματοποιείται ταυτόχρονα με τους αντίστοιχους υπολογισμούς. Αυτό προσθέτει ένα επιπλέον κόστος, της τάξεως των \(0.005\ secs/frame\), στον χρόνο εκτέλεσης της εφαρμογής. Το μικρό επιπλέον κόστος οφείλεται στο εύρος ζώνης του διαύλου \ac{EIB} (\(96\ B/cycle\)), το οποίο είναι ικανό να ικανοποιήσει όλες τις αιτήσεις που πραγματοποιούνται με πολύ μικρή καθυστέρηση.\newline \indent
Παρά το μικρό επιπλέον κόστος, η διαδικασία της μεταφοράς δεδομένων επιταχύνεται με την εφαρμογή της τεχνικής του \textsl{double-buffering}. Για την μεταφορά των δεδομένων, δεσμεύονται δύο ξεχωριστοί \textsl{buffers}. Κατ' αυτό τον τρόπο είναι δυνατή η επικάλυψη των υπολογισμών για το \textsl{Ν}-οστό \textsl{tile} με την μεταφορά των δεδομένων για το \textsl{(Ν+1)}-οστό \textsl{tile} προς την \ac{LS} και την μεταφορά των δεδομένων για το \textsl{(Ν-1)}-οστό \textsl{tile} προς την κύρια μνήμη. Η ενσωμάτωση αυτής της τεχνικής επικαλύπτει δραστικά την καθυστέρηση για την πρόσβαση στην μνήμη, αυξάνοντας όμως τόσο τις απαιτήσεις σε μνήμη για την αποθήκευση των \textsl{pixels} όσο και την πολυπλοκότητα του κώδικα καθώς απαιτείται η εναλλαγή μεταξύ των διαθέσιμων \textsl{buffers}. Η συνεισφορά της εξάλειψης αυτού του μικρού κόστους είναι περισσότερο σημαντική στην τελική έκδοση του κώδικα.

\subsection[4.2.2 Διανυσματοποίηση Υπολογισμών και Ξεδίπλωμα Βρόχου]{Διανυσματοποίηση Υπολογισμών και Ξεδίπλωμα Βρόχου}
\label{subsection:sub422}
\indent
Το επόμενο βήμα στην διαδικασία βελτιστοποίησης είναι η βελτιστοποίηση του κώδικα που εκτελείται στα \acp{SPE}. Για την βελτιστοποίηση του κώδικα χρησιμοποιήθηκε τόσο μία σειρά από συμβατικούς, μη αυτόματους μετασχηματισμούς για την εκμετάλλευση στοιχείων της αρχιτεκτονικής των \acp{SPE} όπως οι διανυσματικές μονάδες επεξεργασίας ή το \textsl{dual-issue pipeline} όσο και μη συμβατικούς μετασχηματισμούς που δεν εφαρμόζονται τυπικά σε βαθμωτούς επεξεργαστές γενικού σκοπού. Τόσο η παρούσα όσο και οι υπόλοιπες υποενότητες περιγράφουν τις βελτιστοποιήσεις που εφαρμόσθηκαν. Εδώ θα πρέπει να αναφερθεί ότι, παρά τις εξελιγμένες λειτουργίες για την παραγωγή κώδικα που ενσωματώνονται στους δύο μεταγλωττιστές, \textsl{gcc} και \textsl{xlc}, που χρησιμοποιήθηκαν για την μεταγλώττιση του κώδικα για τον \ac{CBEA}, δεν ήταν δυνατή η αυτόματη εφαρμογή κάποιων από τους απαιτούμενους μετασχηματισμούς, όπως για παράδειγμα η \textsl{διανυσματοποίηση των υπολογισμών}.\newline \indent
Η πλειονότητα των υπολογισμών που πραγματοποιούνται στα \acp{SPE} εσωκλείονται σε διπλά \textsl{for-loops}. Το εξωτερικό \textsl{loop}, το οποίο διατρέχει όλα τα \textsl{pixels} (\textsl{pixel scan}), αρχικά υπολογίζει τις κλασματικές συντεταγμένες για όλα τα \textsl{pixels} εντός του \textsl{tile} (\textsl{Inverse Mapping}) και έπειτα εφαρμόζει την συνάρτηση \textsl{Bicubic Interpolation} για την εφαρμογή του σχήματος παρεμβολής. Και το σχήμα παρεμβολής χρησιμοποιεί δύο εμφωλευμένα \textsl{for-loops}, όπου το ένα \textsl{loop} διατρέχει τις τρεις συνιστώσες χρώματος της εικόνας (\textsl{RGB}). Ομοίως, και στην συνάρτηση \textsl{Low-Pass Filter} χρησιμοποιούνται δύο εξωτερικά \textsl{for-loops}, ένα για κάθε μία κατεύθυνση εφαρμογής του φίλτρου (οριζόντια και κάθετη). Καθένα από αυτά τα \textsl{loops} περικλείει ένα εσωτερικό \textsl{loop} με τρεις επαναλήψεις για τις τρεις συνιστώσες του χρώματος της εικόνας.\newline \indent
Για την επιτάχυνση των υπολογισμών που πραγματοποιούνται, εκμεταλλευόμαστε τον \textsl{παραλληλισμό μεταξύ δεδομένων} (\ac{DLP}) και τις δυνατότητες διανυσματικών υπολογισμών των \acp{SPE}, ομαδοποιώντας τέσσερεις τελεστέους κινητής υποδιαστολής, απλής ακρίβειας σε έναν διανυσματικό καταχωρητή. Με χρήση αυτού του σχήματος, η συνάρτηση \textsl{Inverse Mapping} παράγει τέσσερα ζεύγη συντεταγμένων σε μία επανάληψη, ενώ το μονοδιάστατο \textsl{stencil} για το σχήμα παρεμβολής εφαρμόζεται σε τέσσερα \textsl{pixels} σε κάθε επανάληψη. Καθώς τα \acp{SPE} δαπανούν τον περισσότερο χρόνο  στα προαναφερθέντα \textsl{loops}, η παραλληλοποίηση με χρήση πράξεων \ac{SIMD} μπορεί να επιταχύνει την εκτέλεση των υπολογισμών, με μέγιστο παράγοντα επιτάχυνσης ίσο με \(4\).\newline \indent
Αυτό το έμμεσο ξεδίπλωμα βρόχου (\textsl{loop unrolling}) λόγω της διανυσματοποίησης των υπολογισμών έχει το επιπλέον επιθυμητό αποτέλεσμα της μείωσης των διακλαδώσεων που πραγματοποιούνται προς την αρχή του κάθε βρόχου κατά έναν παράγοντα ίσο με \(4\). Η λανθασμένη πρόβλεψη διακλαδώσεων συνεπάγεται μία αρκετά μεγάλη καθυστέρηση, περίπου \(20\) κύκλους ρολογιού, ενώ η καθυστέρηση στην εκτέλεση μίας τυπικής εντολής κυμαίνεται μεταξύ \(2\) και \(7\) κύκλων ρολογιού. Η καθυστέρηση από την λανθασμένη πρόβλεψη διακλαδώσεων υπάρχει πάντα στην περίπτωση των προς τα πίσω διακλαδώσεις που υπάρχουν στα \textsl{for-loops} καθώς τα \acp{SPE} προβλέπουν\footnote{\small Η πρόβλεψη της κατεύθυνσης των διακλαδώσεων στα \acp{SPE} δύναται να αλλαχθεί είτε μέσω εντολών που εισάγει ο προγραμματιστής (\textsl{intrinsics}) είτε μέσω εντολών \textsl{assembly} που εισάγονται από τον μεταγλωττιστή.} πάντα τις διακλαδώσεις ως \textsl{μη αληθείς} (\textsl{not taken}).\newline \indent 
Για την περαιτέρω εκμετάλλευση των θετικών αποτελεσμάτων της εξάλειψης των εντολών διακλάδωσης πραγματοποιήθηκε ξεδίπλωμα των εσωτερικών βρόχων που διατρέχουν τις τρεις συνιστώσες χρώματος (\textsl{R}, \textsl{G} και \textsl{B}), με παράγοντα ξεδιπλώματος ίσο με \(3\). Αυτό το ξεδίπλωμα είχε ως αποτέλεσμα την πλήρη εξάλειψη των εντολών διακλάδωσης που εμπεριέχονταν σε αυτούς τους βρόχους.\newline \indent 
Εκτός από την εξάλειψη των εντολών διακλάδωσης, το ξεδίπλωμα βρόχου έχει ως αποτέλεσμα την ύπαρξη περισσοτέρων εντολών προς δρομολόγηση. Κατ' αυτό τον τρόπο, ο μεταγλωττιστής μπορεί να εκτελέσει μία καλύτερη δρομολόγηση των εντολών, εξαλείφοντας έτσι πιθανά παγώματα στο \textsl{pipeline} λόγω εξαρτήσεων μεταξύ εντολών. Το μόνο μειονέκτημα της τεχνικής του \textsl{ξεδιπλώματος βρόχου} είναι η πίεση που υπάρχει στην χρήση των καταχωρητών (\textsl{register pressure}), η οποία ενδέχεται να οδηγήσει στην απώλεια όλων ή μερικών από τα πλεονεκτήματα αυτής της τεχνικής. Όπως προέκυψε με χρήση του προσομοιωτή, η χρήση των καταχωρητών αυξήθηκε όταν χρησιμοποιήθηκε η τεχνική του \textsl{ξεδιπλώματος βρόχου}. Όμως, ο μεγάλος αριθμός των διαθέσιμων καταχωρητών στα \acp{SPE}, καθιστά δυνατή την αποθήκευση όλων των \textsl{ενεργών τιμών} (\textsl{live values}) που εμφανίζονται εντός του βρόχου, επιτρέποντας την πλήρη εκμετάλλευση των δυνατοτήτων της τεχνικής του \textsl{ξεδιπλώματος βρόχου}.\newline \indent
Ο πίνακας~\ref{table:tab41} παρουσιάζει τα αποτελέσματα από τις δύο προαναφερθείσες βελτιστοποιήσεις του κώδικα με χρήση των \(6\) \acp{SPE} του \textsl{PS3}. Όπως παρατηρούμε, η πρώτη βελτιστοποίηση επιτρέπει την επιτάχυνση της εφαρμογής με παράγοντα ίσο με \(9.03\) σε σύγκριση με την αρχική έκδοση του κώδικα και μειώνει το κόστος λόγω των παγωμάτων του \textsl{pipeline} που δημιουργούνται από την λανθασμένη πρόβλεψη διακλαδώσεων από \(12.5\%\) σε \(3.1\%\) του συνολικού αριθμού των εντολών. Το ξεδίπλωμα των εσωτερικών βρόχων μειώνει περισσότερο τον χρόνο εκτέλεσης της εφαρμογής σε \(0.07\ secs/frame\), ο οποίος συνεπάγεται έναν παράγοντα επιτάχυνσης ίσο με \(12x\). Επίσης, και οι δύο βελτιστοποιήσεις οδηγούν σε αύξηση της χρησιμοποίησης του \textsl{dual-issue} καθώς υπάρχουν περισσότερες διαθέσιμες εντολές προς δρομολόγηση. Επιπλέον ξεδίπλωμα των βρόχων δεν οδηγούσε σε σημαντική μείωση του χρόνου εκτέλεσης της εφαρμογής ενώ είχε ως αποτέλεσμα την σημαντική αύξηση του μεγέθους του κώδικα.
\begin{table}
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
Optimization & Execution & Speed Up & Branch & Dual Issue \\
             & Time (sec) & compared with (A) & Misprediction & \\
             &                      &          & stalls (\% cycles) & \\ \hline
(A) Coarse grain & 0.84 & 1 & 12.5\% & 11.6\% \\
parallelization  &      &   &        & \\ \hline
%parallelization & & &\\ \hline
(B) Vectorization & 0.093 & 9.03 & 3.1\% & 20.1\%\\
and 4x unroll     &       &      &       & \\ \hline
(C) 3x inner & 0.07 & 12 & 2.6\% & 22.6\%\\
loop unroll  &      &    &       & \\ \hline
\end{tabular}
\caption{Χρόνος εκτέλεσης, παράγοντας επιτάχυνσης, κόστος λανθασμένων προβλέψεων διακλάδωσης και χρήση του \textsl{dual-issue} πριν και μετά την εφαρμογή της τεχνικής του \textsl{ξεδιπλώματος βρόχου}.}
\label{table:tab41}
\end{table}
\indent

\subsection[4.2.3 Μη Ευθυγραμμισμένες Φορτώσεις από την Μνήμη]{Μη Ευθυγραμμισμένες Φορτώσεις από την Μνήμη}
\label{subsection:sub423}
\indent
Ένα ιδιαίτερο χαρακτηριστικό της συνάρτησης \textsl{Bicubic Interpolation} είναι οι μη ευθυγραμμισμένες προσβάσεις στην μνήμη. Στις περισσότερες περιπτώσεις, το επάνω αριστερά \textsl{pixel} της \(4x4\) γειτονιάς που χρησιμοποιείται για την παρεμβολή βρίσκεται σε διεύθυνση η οποία δεν είναι πολλαπλάσια των \(16\ bytes\) (\textsl{vector alignment}). Αυτό αποτελεί μία πρόκληση κατά την διαδικασία της διανυσματοποίησης των υπολογισμών. Στην περίπτωση της φόρτωσης των βαθμωτών μεταβλητών από μη ευθυγραμμισμένες διευθύνσεις μνήμης, ο μεταγλωττιστής του εκτελέσιμου για τα \acp{SPE} εισάγει επιπλέον βοηθητικές εντολές και εντολές μετατόπισης ώστε να μεταφερθεί η βαθμωτή μεταβλητή στο \textsl{preferred slot}.\newline \indent 
Για να διαπιστωθεί η επίδραση αυτών των φορτώσεων από την μνήμη χρησιμοποιήθηκε το εργαλείο \textsl{spu\_timing}, το οποίο παρέχεται με το \textsl{Cell BE SDK}, για την στατική ανάλυση του κώδικα της εφαρμογής. Η στατική ανάλυση του \textsl{pipeline} των \acp{SPE} έδειξε ότι η πλειονότητα των παγωμάτων του \textsl{pipeline} οφειλόταν στις μη ευθυγραμμισμένες προσβάσεις στην μνήμη που απαιτούνται για τον σχηματισμό των \(4x4\) γειτονιών. Τα τέσσερα \textsl{pixels} στην κάθε γραμμή της γειτονιάς, για κάθε χρώμα, φορτώνονται ως αριθμοί κινητής υποδιαστολής απλής ακρίβειας στον ίδιο διανυσματικό καταχωρητή. Αυτή η μετατροπή από ακεραίους σε αριθμούς κινητής υποδιαστολής απλής ακρίβειας είναι απαραίτητη καθώς μετέπειτα υπολογισμοί στα \textsl{pixels} χρησιμοποιούν αριθμητική κινητής υποδιαστολής. Καθώς κάθε φόρτωση στον εκάστοτε διανυσματικό καταχωρητή εκτελείται ατομικά για κάθε \textsl{pixel} στην ίδια σειρά, οι εξαρτήσεις που δημιουργούνται από προηγούμενες φορτώσεις εισάγουν παγώματα σε μετέπειτα φορτώσεις στον ίδιο καταχωρητή, μετατρέποντας τον διανυσματικό καταχωρητή σε ένα \textsl{σημείο ανταγωνισμού} (\textsl{contention point}).\newline \indent
Για την αποφυγή των παγωμάτων λόγω των εξαρτήσεων που δημιουργούνται, αντιστρέφουμε την σειρά σύμφωνα με την οποία πραγματοποιούνται οι φορτώσεις των καταχωρητών. Αρχικά πραγματοποιείται η φόρτωση της πρώτης στήλης από \textsl{pixels}, έπειτα η φόρτωση της δεύτερης στήλης, κοκ. Και σε αυτό το σχήμα φόρτωσης συνεχίζουμε να χρησιμοποιούμε έναν καταχωρητή για την αποθήκευση κάθε γραμμής από \textsl{pixels} αλλά τροποποιούμε την ακολουθία βάσει της οποίας πραγματοποιείται η φόρτωση των δεδομένων (Σχήμα~\ref{figure:fig25}). Η τροποποίηση αυτή διαχωρίζει τις διαδοχικές εντολές που χρησιμοποιούν τον ίδιο καταχωρητή, εισάγοντας έναν ικανό αριθμό από εντολές ενδιάμεσα αυτών και αυξάνοντας το χρονικό διάστημα μεταξύ της φόρτωσης ενός \textsl{pixels} σε έναν καταχωρητή και της φόρτωσης του επόμενου \textsl{pixel} στο ίδιο καταχωρητή.\newline \indent 
Θα πρέπει να σημειωθεί ότι αυτή η δρομολόγηση των εντολών αντιβαίνει στην κοινή διαίσθηση, καθώς οι βελτιστοποιήσεις που εισάγουν οι μεταγλωττιστές τείνουν να οργανώνουν τις προσβάσεις στην μνήμη κατά σειρές. Αυτή η βελτιστοποίηση είχε ως αποτέλεσμα την μείωση του χρόνου εκτέλεσης της εφαρμογής σε \(0.06\ secs/frame\).
\begin{figure}[b]
\centering
\includegraphics[width=6in, height=3in]{Chapter4/figures/figure5.eps}
\caption{Η απόδοση του αλγορίθμου διόρθωσης της παραμόρφωσης που προκαλείται από τους ευρυγώνιους φακούς στον επεξεργαστή \textsl{Core2 Duo} και στην αρχιτεκτονική \textsl{CBEA} για όλες τις βελτιστοποιήσεις.}
\label{figure:fig45}
\end{figure}

\subsection[4.2.4 Διανυσματοποίηση Συνθηκών Βρόχων και Χειροκίνητη Δρομολόγηση Εντολών]{Διανυσματοποίηση Συνθηκών Βρόχων και Χειροκίνητη Δρομολόγηση Εντολών}
\label{subsection:sub424}
\indent
Η συνάρτηση \textsl{Bicubic Interpolation} εμπεριέχει την ακόλουθη συνθήκη βρόχου ώστε να διαπιστωθεί κατά πόσο ένα σημείο με συντεταγμένες \((X,Y)\) βρίσκεται εκτός των ορίων του \textsl{frame}. Σε περίπτωση που αυτό ισχύει, το χρώμα του αντίστοιχου \textsl{pixel} τίθεται σε μαύρο, το οποίο αντιστοιχεί σε μηδενική τιμή για κάθε μία από τις συνιστώσες χρώματος του συστήματος \textsl{RGB}. Οι τιμές αυτές αποθηκεύονται στον πίνακα \textsl{lpf}, ο οποίος χρησιμοποιείται ως ενδιάμεσος \textsl{buffer} όπου αποθηκεύονται τα αποτελέσματα από την εφαρμογή του βαθυπερατού φίλτρου στην κάθετη διεύθυνση:\newline
\begin{lstlisting}
if ((X < 0) || (X > (Width - 1)) ||
    (Y < 0) || (Y > (Height- 1)))
    lpf[loc][0]=lpf[loc][1]=lpf[loc][2]=0;
\end{lstlisting}
\indent
Μετά την εφαρμογή των βελτιστοποιήσεων για την χρήση \ac{SIMD} υπολογισμών, υπάρχουν τέσσερεις συνθήκες \textsl{if} στον εξωτερικό βρόχο όπως επίσης και οχτώ συντεταγμένες, ένα ζεύγος συντεταγμένων \((X,Y)\) για καθένα από τα στοιχεία του διανυσματικού καταχωρητή, όπου οι τετμημένες αποθηκεύονται σε έναν καταχωρητή ενώ οι τεταγμένες αποθηκεύονται σε δεύτερο καταχωρητή. Και εδώ αντιμετωπίζουμε ένα πρόβλημα παρόμοιο με αυτό των μη ευθυγραμμισμένων φορτώσεων καθώς απαιτείται η εξαγωγή των συντεταγμένων από τον κάθε καταχωρητή, ο υπολογισμός της τιμής της συνθήκης και η εκτέλεση ή όχι των εντολών που βρίσκονται εντός της συνθήκης \textsl{if}. Όπως η φόρτωση στοιχείων στους καταχωρητές έτσι και η εξαγωγή στοιχείων από αυτούς, εισάγει παγώματα στο \textsl{pipeline} σε περίπτωση που διαδοχικές εντολές προσπελαύνουν τον ίδιο καταχωρητή.\newline \indent
Η προσέγγιση που ακολουθήσαμε για την βελτιστοποίηση αυτών των υπολογισμών, είναι η χρήση διανυσματικών πράξεων για τον υπολογισμό των αποτελεσμάτων των συνθηκών και η μεταφορά αυτών των υπολογισμών στην αρχή του εξωτερικού βρόχου. Ακόμη υπάρχει η ανάγκη για εξαγωγή των αποτελεσμάτων από τους καταχωρητές αλλά πλέον αυτό πραγματοποιείται στην αρχή του εξωτερικού βρόχου, αρκετούς κύκλους πριν από το σημείο όπου χρησιμοποιούνται αυτές οι τιμές.\newline \indent
Παρά την εξάλειψη των περισσοτέρων παγωμάτων του \textsl{pipeline} από την εφαρμογή των ανωτέρω βελτιστοποιήσεων, ο υπολειπόμενος αριθμός παγωμάτων, όπως αυτός προέκυπτε με χρήση του εργαλείου \textsl{spu\_timing}, ήταν σημαντικός και επιβάρυνε αρκετά την απόδοση της εφαρμογής. Το τελευταίο στάδιο βελτιστοποίησης ήταν η εξάλειψη αυτών των παγωμάτων με χειροκίνητη δρομολόγηση των εντολών. Η διαδικασία που ακολουθήθηκε αποτελείται από τα ακόλουθα βήματα:
\begin{itemize}

\item{Παραγωγή του κώδικα \textsl{assembly} για τον κώδικα που εκτελείται στα \acp{SPE}.}

\item{Χρήση του εργαλείου \textsl{spu\_timing} για την επισημείωση του κώδικα \textsl{assembly} με τις πληροφορίες εκτέλεσης της κάθε εντολής στο \textsl{pipeline}.}

\item{Από τις πληροφορίες που παράγονταν στο δεύτερο βήμα εντοπιζόντουσαν σημεία όπου υπήρχαν πολλά παγώματα ή μικρή χρήση του \textsl{dual-issue} και υπήρχε η δυνατότητα αναδιάταξης των εντολών. Έπειτα, αυτή η αναδιάταξη πραγματοποιούνταν στο υψηλότερο επίπεδο του κώδικα, όπου γινόταν αναδιάταξη των εντολών της γλώσσας \textsl{C} με σκοπό την εξάλειψη των παγωμάτων του \textsl{pipeline}.}
\end{itemize}
\indent Ακολουθώντας την ανωτέρω διαδικασία, πραγματοποιήσαμε την διεμπλοκή, \textsl{interleaving}, των εντολών για μη ευθυγραμμισμένες προσβάσεις στην μνήμη με εντολές που πραγματοποιούν υπολογισμούς επιτρέποντας στον μεταγλωττιστή μία πιο αποδοτική δρομολόγηση των διαθέσιμων εντολών. Το ξεδίπλωμα του εσωτερικού βρόχου (ο βρόχος που διατρέχει τις τρεις συνιστώσες χρώματος), όπως περιγράφεται στην υποενότητα~\ref{subsection:sub422}, διευκολύνει την χειροκίνητη δρομολόγηση των εντολών μέσω του μεγάλου αριθμού των εντολών για τις οποίες υπάρχει η δυνατότητα διεμπλοκής. Εδώ θα πρέπει να αναφερθεί ότι ο μεταγλωττιστής δεν απεδείχθη αρκετά αποδοτικός στην δρομολόγηση ανεξάρτητων εντολών καθώς η δρομολόγηση των εντολών πραγματοποιούνταν μόνο σε τοπικό επίπεδο.\newline \indent
\begin{table}
\centering
\begin{tabular}{|c|c|}
\hline
Βελτιστοποίηση & Κύρια επίδραση στην απόδοση \\ \hline
DMA Double-Buffering & Μείωση του αδρανούς χρόνου και \\
                     & επικάλυψη μεταφοράς δεδομένων με υπολογισμούς \\ \hline
Διανυσματοποίηση υπολογισμών & Μείωση των εντολών διακλάδωσης \\
(έμμεσο ξεδίπλωμα βρόχου & και αύξηση των διαθέσιμων εντολών\\
με παράγοντα 4x) & προς δρομολόγηση \\ \hline
Ξεδίπλωμα & Όμοια με την προηγούμενη βελτιστοποίηση\\
εσωτερικού βρόχου & \\ \hline
Φόρτωση καταχωρητών κατά στήλες & Εξάλειψη των παγωμάτων λόγω μη ευθυγραμμισμένων \\
                                & φορτώσεων και διαδοχικών χρήσεων \\
                                & του ιδίου καταχωρητή \\ \hline
Χειροκίνητη δρομολόγηση εντολών & Μείωση αρκετών παγωμάτων του \textsl{pipeline} \\
                                & μέσω της ταυτόχρονης δρομολόγησης \\
                                & ανεξάρτητων εντολών και της εξάλειψης \\
                                & των διαφόρων εξαρτήσεων \\ \hline
\end{tabular}
\caption{Οι βελτιστοποιήσεις που πραγματοποιήθηκαν και η κύρια επίδραση αυτών στην απόδοση της εφαρμογής.}
\label{table:tab42}
\end{table}
Ο πίνακας~\ref{table:tab42} συνοψίζει τις βελτιστοποιήσεις που πραγματοποιήθηκαν και την κύρια επίδραση αυτού στην απόδοση της εφαρμογής και το σχήμα~\ref{figure:fig45} απεικονίζει την απόδοση του αλγορίθμου μετά από την εφαρμογή κάθε μετασχηματισμού βελτιστοποίησης που περιγράφηκε στην παρούσα ενότητα. Όπως παρατηρούμε, η εκμετάλλευση του \textsl{coarse-grain} παραλληλισμού μεταξύ των δεδομένων με χρήση των διαθέσιμων \acp{SPE}, του \textsl{fine-grain} παραλληλισμού, όπως η διανυσματοποίηση των υπολογισμών, και η εξάλειψη των εντολών διακλάδωσης προς τα πίσω που υπάρχουν στους βρόχους αποδείχθηκαν ως οι πιο αποτελεσματικές βελτιστοποιήσεις. Η τελική έκδοση του κώδικα απαιτεί μόνο \(0.05\ secs\) για την επεξεργασία ενός \textsl{frame} ώστε επιτυγχάνεται η διόρθωση \(20\) \(frames/sec\). Χαρακτηριστική είναι και η αύξηση της χρήσης του \textsl{dual-issue} από \(22.6\%\) σε \(34.6\%\) μετά την εφαρμογή της χειροκίνητης δρομολόγησης των εντολών, όπως προκύπτει από το \textsl{profiling} της εφαρμογής στον προσομοιωτή.\newline \indent
Βάσει των αποτελεσμάτων, παρόλο που η εκτέλεση της εφαρμογής είτε με ένα είτε με δύο νήματα στον επεξεργαστή \textsl{Core2 Duo} ήταν αποτελεσματικότερη από την εκτέλεση αυτής στο \ac{PPE} κατά έναν παράγοντα ίσο με \(4.29x\) και \(7.5x\) αντίστοιχα, ο συνδυασμός του \ac{PPE} (ως επεξεργαστή ελέγχου) και των \(6\) διαθέσιμων \acp{SPE} (ως επεξεργαστές για την εκτέλεση των υπολογισμών) οδηγεί στην πιο γρήγορη εκτέλεση της εφαρμογής κατά έναν παράγοντα ίσο με \(4.8x\) σε σύγκριση με την πολυνηματική εκτέλεση στον επεξεργαστή \textsl{Core2 Duo} όταν ο κώδικας έχει βελτιστοποιηθεί (βλ. την γραμμή με το μαύρο χρώμα στο σχήμα~\ref{figure:fig43}). Αυτή η παρατήρηση επιβεβαιώνει την δυνατότητα της αρχιτεκτονικής \ac{CBEA} για την εκμετάλλευση του παραλληλισμού σε πολλαπλά επίπεδα που υπάρχει στις διάφορες εφαρμογές. Όμως, για την εκμετάλλευση αυτού του παραλληλισμού είναι αναγκαία η εφαρμογή εκτεταμένων βελτιστοποιήσεων στον κώδικα της εφαρμογής.

\section{Σχετικές Εργασίες}
\label{section:sect43}
\indent
Ο επεξεργαστής \ac{CBE} αρχικά προοριζόταν για την αγορά των πολυμέσων και των ηλεκτρονικών παιχνιδιών. Ωστόσο σύντομα προσέλκυσε το ενδιαφέρον της επιστημονικής κοινότητας λόγω της μεγάλης υπολογιστικής δύναμης και της μεγάλης αποδοτικότητας τόσο σε σχέση με την ισχύ που καταναλώνεται όσο και με την τιμή αυτού.\newline \indent
Έχει χρησιμοποιηθεί επιτυχώς σε μία πλειάδα εφαρμογών όπως δημιουργία ιατρικών εικόνων \cite{Knaupetal07}, υπολογιστική βιολογία \cite{Sachdeva07}, προσομοιώσεις μεταφοράς σωματιδίων \cite{Petrini07}, εξόρυξη γνώσης \cite{BaderAgarwalMadduri07, BuehrerParthasarathyGoyder08}, on-line συστήματα ανίχνευσης εισβολών σε δίκτυα υπολογιστών \cite{ScarpazzaVillaPetrini07}, εικονοαπόδοση του περιβάλλοντος (\textsl{terrain rendering}) \cite{TRE} ακόμη και σε εφαρμογές υπολογιστικής άλγεβρας \cite{linpack}. Είναι επίσης μία δημοφιλής πλατφόρμα για την ανάπτυξη εφαρμογών επεξεργασίας πολυμέσων όπως αποκωδικοποίηση βίντεο υψηλής ανάλυσης \cite{BaikSihnKim07} και αναγνώριση ομιλίας \cite{Liu07}. Αυτού του είδους οι εφαρμογές χαρακτηρίζονται από μεγάλες απαιτήσεις σε υπολογιστική ισχύ, μικρό λόγο μεταφοράς δεδομένων προς υπολογισμούς και συχνά απαιτούν επεξεργασία σε πραγματικό χρόνο.\newline \indent
Οι αυστηρές απαιτήσεις ευθυγράμμισης που θέτει η αρχιτεκτονική του επεξεργαστή συχνά αποτελεί έναν σημαντικό ανασχετικό παράγοντα της απόδοσης υπολογιστικών πυρήνων που βασίζονται σε υπολογισμούς με \textsl{stencils}. Στις εργασίες \cite{KamilDattaetal06, WilliamsShalf06} οι συγγραφείς αποτιμούν την εκτέλεση τέτοιου είδους εφαρμογών στον επεξεργαστή \ac{CBE} και προτείνουν την εφαρμογή των τεχνικών του \textsl{blocking} και του \textsl{time skewing} \cite{Wonnacott00} για την αύξηση της τοπικότητας και την αύξηση των υπολογισμών έναντι της επικοινωνίας που απαιτεί η εφαρμογή.\newline \indent
Η μη ώριμη τεχνολογία των υπαρχόντων μεταγλωττιστών δημιούργησε έντονο ενδιαφέρον για την ανάπτυξη μεταγλωττιστών με εξειδικευμένες δυνατότητες για τον επεξεργαστή \ac{CBE}. Οι συγγραφείς στην εργασία \cite{Eichenbergeretal06} προτείνουν τεχνικές μεταγλώττισης που στοχεύουν στην αυτόματη παραγωγή αποδοτικού κώδικα για τον επεξεργαστή \textsl{Cell}. Αυτές οι τεχνικές περιλαμβάνουν ευθυγράμμιση μνήμης και πρόβλεψη διακλαδώσεων υποβοηθούμενες από τον μεταγλωττιστή, παραλληλοποίηση σε επίπεδο νημάτων και σε επίπεδο πράξεων \ac{SIMD} και \textsl{caching} με λογισμικό που ελέγχεται από τον μεταγλωττιστή. Παρόμοια, οι \textsl{Zhao} και \textsl{Kennedy} \cite{ZhaoKennedy06} παρουσιάζουν έναν μεταγλωττιστή για τον επεξεργαστή \textsl{Cell} ο οποίος προσφέρει αυτοματοποιημένη παραλληλοποίηση των βρόχων που βασίζεται σε ανάλυση των εξαρτήσεων και αυτόματη \ac{SIMD} παραλληλοποίηση των υπολογισμών.
