\chapter{Μελέτη της Απόδοσης της Εφαρμογής}
\label{chapter:chap6}

Σε αυτό το κεφάλαιο επιχειρείται μία λεπτομερής ανάλυση της απόδοσης της εφαρμογής στον επεξεργαστή \textsl{Cell}, σε έναν επεξεργαστή \textsl{Core2 Quad} από την \textsl{Intel} και σε μία \textsl{Virtex-4 LX80} \ac{FPGA}. To κεφάλαιο αυτό διαφέρει από το Κεφάλαιο~\ref{chapter:chap4} καθώς όλα τα αποτελέσματα αναφέρονται στην εκτέλεση της εφαρμογής σε πραγματικό \textsl{hardware} χωρίς την ύπαρξη αποτελεσμάτων από προσομοιώσεις. Με την εκτέλεση της εφαρμογής σε πραγματικό \textsl{hardware} επιτυγχάνεται η λήψη πιο λεπτομερών μετρήσεων τόσο για μετρικές που αναφέρθηκαν και στο Κεφάλαιο~\ref{chapter:chap4} όσο και για μετρικές χαμηλού επιπέδου οι οποίες δεν ήταν δυνατόν να ληφθούν μέσω προσομοιώσεων. Αρχικά περιγράφεται το σύστημα με τον επεξεργαστή \textsl{Cell} που χρησιμοποιήθηκε, ο επεξεργαστής \textsl{Intel Core2 Quad} και η \textsl{Virtex-4 LX80} \ac{FPGA} και έπειτα γίνεται η ανάλυση των διαφόρων μετρήσεων. Η ανάλυση αυτή στοχεύει στον χαρακτηρισμό της εφαρμογής σε αντιπροσωπευτικές πλατφόρμες από τις πιο σύγχρονες κατηγορίες συστημάτων που χρησιμοποιούνται για την ανάπτυξη εφαρμογών.

\section{Περιγραφή των Συστημάτων}
\label{section:sect61}

\subsection[6.1.1 IBM BladeCenter QS20]{IBM BladeCenter QS20}
\label{subsection:sub611}
\indent
Το σύστημα \textsl{IBM BladeCenter QS20} αποτελείται από ένα μοναδικό \textsl{blade} που ενσωματώνει δύο επεξεργαστές \ac{CBEA}. Περισσότερα του ενός συστήματα \textsl{IBM BladeCenter QS20} μπορούν να συνδεθούν μεταξύ τους για την δημιουργία ενός πιο ισχυρού υπολογιστικού συστήματος. Το σύστημα που χρησιμοποιήθηκε για την εκτέλεση της εφαρμογής και την λήψη των μετρήσεων για τον επεξεργαστή \ac{CBEA} ενσωματώνει εξωτερική μνήμη \textsl{DRAM} μεγέθους ίσου με \(1\ GB\).

\subsection[6.1.2 Intel Core2 Quad]{Intel Core2 Quad}
\label{subsection:sub612}
\indent
Ο επεξεργαστής \textsl{Intel Core2 Quad Q9300} είναι ένας αντιπροσωπευτικός επεξεργαστής που ανήκει στους ομογενείς επεξεργαστές πολλαπλών πυρήνων. Η συχνότητα λειτουργίας του επεξεργαστή είναι ίση με \(2.5\ GHz\) και η συχνότητα λειτουργίας του \ac{FSB} είναι ίση με \(1.3\ GHz\). Ο επεξεργαστής είναι οργανωμένος ως δύο \textsl{blocks} επεξεργαστών διπλού πυρήνα, οι οποίοι επικοινωνούν με χρήση του \ac{FSB}. Κάθε ένα από τα δύο \textsl{blocks} διπλού πυρήνα εμπεριέχει μία \textsl{L2 cache} μεγέθους \(3\ MB\), (\(12\) \textsl{way set associative}), με μέγεθος \textsl{cache line} ίσο με \(64\ bytes\) η οποία διαμοιράζεται μεταξύ των δύο πυρήνων του \textsl{block}. Επιπλέον, κάθε πυρήνας έχει αποκλειστική πρόσβαση σε μία \textsl{L1 cache} μεγέθους \(64\ KB\) (\(32\ KB\) για δεδομένα και \(32\ KB\) για τον κώδικα, \(8\) \textsl{way set associative}, με μέγεθος \textsl{cache line} ίσο με \(64\ bytes\)). Ο επεξεργαστής υποστηρίζει το σύνολο εντολών \ac{SSE} \(4.1\) και η μέση κατανάλωση ισχύος του επεξεργαστή είναι ίση με \(95\ W\). Το σύστημα που χρησιμοποιήθηκε για την συγκέντρωση των αντίστοιχων αποτελεσμάτων εμπεριέχει μία μνήμη \textsl{RAM}, μεγέθους \(2\ GB\) και με συχνότητα λειτουργίας ίση με \(667\ MHz\).

\subsection[6.1.3 Αναδιατασσόμενη Λογική]{Αναδιατασσόμενη Λογική}
\label{subsection:sub613}
\indent
Σε αντίθεση με τις δύο προαναφερθείσες πλατφόρμες \textsl{αμετάβλητης λογικής} (\textsl{fixed logic}), η τρίτη πλατφόρμα που χρησιμοποιήθηκε είναι μία συσκευή αναδιατασσόμενης λογικής (\ac{FPGA}). Μία τέτοιου είδους συσκευή είναι ουσιαστικά ένας υψηλής πυκνότητας πίνακας με \textsl{blocks} λογικής τα οποία διαμορφώνονται μετά την κατασκευή της συσκευής \cite{ComptonSurvey}. Η λειτουργικότητα των \acp{FPGA} καθορίζεται με χρήση των λεγόμενων \textsl{configuration bits}, τα οποία καθορίζουν την λειτουργικότητα των επιμέρους λογικών μονάδων και της λογικής που χρησιμοποιείται για την διασύνδεση των λογικών μονάδων. Πρόσφατες \acp{FPGA} ενσωματώνουν και τμήματα από σταθερή λογική (\textsl{hard IP logic}) όπως μικροεπεξεργαστές γενικού σκοπού, τμήματα για \ac{DSP} και λογική για την υλοποίηση \ac{SRAMs} εντός της \ac{FPGA}.\newline \indent
Σε σύγκριση με τα συστήματα \ac{ASIC} τα οποία δημιουργούνται με γνώμονα τις ανάγκες συγκεκριμένης εφαρμογής ή κλάσης εφαρμογών οπότε προσφέρουν ελάχιστη ευελιξία, οι \acp{FPGA} προσφέρουν το πλεονέκτημα την μεγάλης ευελιξίας όσον αφορά στην προσαρμογή της αρχιτεκτονικής στις ανάγκες της εκάστοτε εφαρμογής. Σε αντίθεση με τους επεξεργαστές \textsl{Core2 Quad} και \ac{CBEA}, οι \acp{FPGA} δεν ακολουθούν την παραδοσιακή αρχιτεκτονική συνόλου εντολών που βασίζεται στο μοντέλο \textsl{von-Neumann}. Επομένως, υπάρχει το \textsl{trade-off} μεταξύ των διαθέσιμων υπολογιστικών πόρων και της απόδοσης της εφαρμογής καθώς ο προγραμματιστής έχει την δυνατότητα να επιλέξει το απαραίτητο επίπεδο παραλληλισμού για την εφαρμογή. Αυτή η ευελιξία καθιστά τις \acp{FPGA} ενεργειακά αποδοτικότερες, συγκρινόμενες με οποιοδήποτε σύστημα γενικού σκοπού.\newline \indent
Τα κύρια μειονεκτήματα αυτής της αρχιτεκτονικής είναι η μεγάλη πολυπλοκότητα για την ανάπτυξη εφαρμογών και η μικρή συχνότητα λειτουργίας παρά την μεγάλη κλιμάκωση της τεχνολογίας κατασκευής των \acp{FPGA}\footnote{\small Οι νεότερης τεχνολογίας Virtex-6 \acp{FPGA} από την Xilinx θα υλοποιηθούν σε τεχνολογία CMOS 40nm.}. Το πρώτο μειονέκτημα προκύπτει από την φύση των \acp{FPGA} καθώς ο προγραμματισμός τους γίνεται με χρήση \ac{HDL} (\textsl{VHDL} ή \textsl{Verilog}). Αυτές οι γλώσσες απαιτούν αφενός μεν αρκετό χρόνο για την ανάπτυξη της εφαρμογής, αφετέρου δε την εξειδικευμένη γνώση λεπτομερειών χαμηλού επιπέδου της αρχιτεκτονικής του συστήματος. Παρ' όλο που υπάρχει μία συνεχής τάση για τον προγραμματισμό των \acp{FPGA} με χρήση γλωσσών προγραμματισμού υψηλού επιπέδου, οι περισσότεροι προγραμματιστές συνεχίζουν να χρησιμοποιούν γλώσσες \ac{HDL}.\newline \indent 
Όσον αφορά στην συχνότητα λειτουργίας του ρολογιού, αυτή είναι μικρότερη (τουλάχιστον κατά μία τάξη μεγέθους) από τις συχνότητες λειτουργίας των επεξεργαστών υψηλής απόδοσης που έχουν σχεδιασθεί χρησιμοποιώντας \textsl{full custom} σχεδίαση. Στην πραγματικότητα, όλες οι σχεδιάσεις \ac{FPGA} λειτουργούν σε συχνότητα ρολογιού μικρότερη των \(200\ MHz\).\newline \indent
Για την υλοποίηση του \textsl{module} που υλοποιεί τον αλγόριθμο διόρθωσης, χρησιμοποιήθηκε μία \textsl{Virtex-4 LX80} \ac{FPGA}. Αυτή η συσκευή εμπεριέχει \(80460\) λογικά \textsl{cells}, \(200\) \ac{SRAMs} εντός του \textsl{chip} με μέγεθος \(18\ Kbit\) έκαστη, και \(80\) τμήματα για την εκτέλεση \ac{DSP} υπολογισμών. Το \textsl{module} που υλοποιεί τον αλγόριθμο είναι τμήμα ενός ενσωματωμένου \textsl{Συστήματος σε Chip} (\ac{SoC}), το οποίο εμπεριέχει έναν επεξεργαστή \textsl{Microblaze}, έναν \textsl{multi-port} ελεγκτή μνήμης για την παροχή υψηλού εύρους ζώνης πρόσβαση στην εξωτερική μνήμη \textsl{SDRAM} και στα υπόλοιπα περιφερειακά. Η συσκευή χρησιμοποιεί ένα ρολόι συχνότητας \(62.5\ MHz\) \cite{xilinx}.\newline \indent
Η δημιουργία του \textsl{module} είναι πλήρως αυτοματοποιημένη και πραγματοποιήθηκε με την χρήση ενός εργαλείου που βασίζεται στο \textsl{architectural synthesis} μοντέλο προγραμματισμού \cite{BellasFCCM}. Το εργαλείο \ac{CAD} παράγει \textsl{hardware accelerators} οι οποίοι ακολουθούν το \textsl{streaming} παράδειγμα αρχιτεκτονικής \cite{AmarasingheThies}. Αυτή η τεχνική παράγει τις απαραίτητες μονάδες για την ανάγνωση/αποθήκευση των δεδομένων που χρησιμοποιούνται για το \textsl{prefetching} των δεδομένων όπως και το \textsl{data path} το οποίο χρησιμοποιείται για την εκτέλεση του προγράμματος και διατυπώνεται μέσω ενός \textsl{streaming διαγράμματος ροής δεδομένων} (\textsl{streaming Data Flow Graph - sDFG}).\newline \indent
Η υλοποίηση του αλγορίθμου στην \ac{FPGA} εκμεταλλεύεται την ευελιξία των διαθέσιμων πόρων οπότε είναι δυνατή η δρομολόγηση ενός μεγάλου αριθμού από πράξεις των \textsl{sDFG} διαγραμμάτων (περίπου \(400\) πράξεις σε όλα τα στάδια του \textsl{pipeline}). Η δρομολόγηση των εντολών σε κάθε κύκλο ρολογιού δημιουργείται από το εργαλείο \ac{CAD} χρησιμοποιώντας το σχήμα \textsl{modulo scheduling} \cite{moduloScheduling}.

\section{Ανάλυση της Απόδοσης της Εφαρμογής}
\label{section:sect62}
\begin{figure}
\centering
\includegraphics[width=4.5in, height=3.5in]{Chapter6/figures/figure1.eps}
\caption{Χρόνος εκτέλεσης και κλιμάκωση της απόδοσης.}
\label{figure:fig61}
\end{figure}
\indent
Σε αυτή την ενότητα αξιολογείται η απόδοση του αλγορίθμου διόρθωσης στις πλατφόρμες που περιγράφηκαν στην ενότητα~\ref{section:sect61}. Όλα τα αποτελέσματα έχουν ληφθεί από την εκτέλεση της εφαρμογής σε πραγματικό υλικό παρά σε προσομοιωτές.\newline \indent
Η παραλληλοποίηση της εφαρμογής στον επεξεργαστή \textsl{Core2 Quad} έγινε με χρήση της βιβλιοθήκης \textsl{POSIX Threads} καθώς η βιβλιοθήκη \textsl{OpenMP} στο λειτουργικό \textsl{Linux} παρουσίαζε προβλήματα στην κλιμάκωση της εφαρμογής για χρήση περισσοτέρων των δύο νημάτων. Για την ανάλυση της απόδοσης της εφαρμογής χρησιμοποιήθηκαν το λογισμικό \textsl{Intel VTune Performance Analyzer} \cite{intelvtune} και το λογισμικό \textsl{Intel Thread Profiler} \cite{threadprofiler}.\newline \indent
Όσον αφορά στην συλλογή των χαμηλού επιπέδου δεδομένων για την απόδοση της εφαρμογής στον επεξεργαστή \ac{CBEA} χρησιμοποιήθηκε το εργαλείο \textsl{Cell Performance Counter} (CPC) το οποίο χρησιμοποιείται για την αρχικοποίηση και την παρακολούθηση των \textsl{hardware performance counters} στον επεξεργαστή \ac{CBEA}. Αυτοί οι \textsl{counters} χρησιμοποιούνται για τον ακριβή προσδιορισμό συγκεκριμένων γεγονότων στο \textsl{hardware} που πραγματοποιούνται κατά την εκτέλεση της εφαρμογής. Σε αντίθεση με το \textsl{PlayStation3}, στο σύστημα \textsl{IBM QS20} είναι δυνατή η χρήση των \textsl{hardware performance counters} λόγω της απουσίας του \textsl{hypervisor}.\newline \indent
Για την μεταγλώττιση του κώδικα για τους δύο επεξεργαστές χρησιμοποιήθηκαν τα εργαλεία και οι επιλογές μεταγλώττισης που περιγράφονται στο Κεφάλαιο~\ref{chapter:chap4}.


\subsection[6.2.1 Μελέτη Απόδοσης και Κλιμάκωσης του Αλγορίθμου]{Μελέτη Απόδοσης και Κλιμάκωσης του Αλγορίθμου}
\label{subsection:sub621}
\indent
Το σχήμα~\ref{figure:fig61} απεικονίζει την απόδοση της εφαρμογής σε κάθε πλατφόρμα βάσει του αριθμού των \textsl{frames} που είναι δυνατόν να επεξεργαστούν σε κάθε δευτερόλεπτο μετά την εφαρμογή της κάθε κατηγορίας βελτιστοποιήσεων. Στην κατηγορία των \textsl{Coarse-Level} (CL) βελτιστοποιήσεων ανήκει η εφαρμογή του \textsl{2D tiling} ενώ στην κατηγορία των \textsl{Fine-Level} (FL) βελτιστοποιήσεων ανήκουν όλες οι βελτιστοποιήσεις που εφαρμόζονται σε πιο χαμηλό επίπεδο όπως για παράδειγμα η εκμετάλλευση του \ac{DLP} που υπάρχει στην εφαρμογή.\newline \indent 
Οι \textsl{FL} βελτιστοποιήσεις αφορούν μόνο στους δύο επεξεργαστές καθώς η μόνη βελτιστοποίηση που έχει εφαρμοσθεί στην \ac{FPGA} είναι η εφαρμογή της τεχνικής του \textsl{tiling}. Η οργάνωση των δεδομένων σε \textsl{tiles} επιτρέπει την εκτέλεση των διαφορετικών σταδίων του αλγορίθμου σε ένα \textsl{pipeline} σχήμα οπότε σε κάθε χρονική στιγμή πολλαπλά \textsl{tiles} επεξεργάζονται στα διάφορα στάδια του \textsl{pipeline}. Επί παραδείγματι, όταν το \textsl{tile} \(N\) βρίσκεται στο στάδιο της παρεμβολής, το \textsl{tile} \(N + 1\) βρίσκεται στο στάδιο της \textsl{αντίστροφης απεικόνισης}. Όσον αφορά στην βελτιστοποίηση \textsl{Inverse Mapping Amortization} αυτή αναφέρεται στον επιμερισμό του κόστους της \textsl{αντίστροφης απεικόνισης} όπως αυτός περιγράφεται στην ενότητα \ref{section:sect52}.\newline \indent
Μία άμεση παρατήρηση είναι η γραμμική εξάρτηση της ταχύτητας εκτέλεσης της εφαρμογής από τον αριθμό των διαθέσιμων νημάτων εκτέλεσης που προσφέρει η κάθε πλατφόρμα. Αυτό επαληθεύει και τα αποτελέσματα που είχαν ληφθεί από τον προσομοιωτή όπως αυτά περιγράφονται στην υποενότητα~\ref{subsubsection:subsub4122}. Σε αυτό συμβάλλουν και οι ιεραρχίες μνήμης και διαύλου οι οποίες καθιστούν δυνατή την πλήρη εκμετάλλευση των δυνατοτήτων των \textsl{data paths} το οποίο σημαίνει ότι η εφαρμογή είναι \textsl{compute bound} για όλες τις περιπτώσεις που μετρήθηκαν. Εάν υποθέσουμε ότι απαιτούμε διόρθωση \(20\) \textsl{frames} το δευτερόλεπτο, τότε μόνο ο επεξεργαστής \ac{CBEA} και η \ac{FPGA} μπορούν να έχουν την επιθυμητή απόδοση. Σε όλες τις περιπτώσεις η αναδιατασσόμενη λογική είναι αυτή που υπερέχει έναντι των \acp{CPU} που ακολουθούν το μοντέλο \textsl{von-Neumann}, καθώς είναι \(37.5\) φορές πιο γρήγορη για κάθε \textsl{Hz} από τον \ac{CBEA} και \(56\) φορές πιο γρήγορη από τον επεξεργαστή \textsl{Intel Core2 Quad}.\newline \indent
Η εκμετάλλευση του \textsl{fine-level} παραλληλισμού μέσω της διανυσματοποίησης των υπολογισμών και της τεχνικής του ξεδιπλώματος βρόχου αποφέρει επιτάχυνση της εφαρμογής ίση με \(12.4x\) για τον επεξεργαστή \ac{CBEA} και επιτάχυνση ίση με \(1.7x\) για τον επεξεργαστή \textsl{Core2 Quad} σε σύγκριση μόνο με την εφαρμογή των \textsl{CL} βελτιστοποιήσεων. Αυτό αποτελεί απόδειξη της προσεχτικής επανεγγραφής του κώδικα (συνήθως μη αυτόματα) που πρέπει να υπάρξει προκειμένου να βελτιστοποιηθεί η εκτέλεση της εφαρμογής στα \acp{SPE} του επεξεργαστή \ac{CBEA}. Η έλλειψη μηχανισμού για την πρόβλεψη διακλαδώσεων και η μη εξελιγμένη τεχνολογία των μεταγλωττιστών για την αυτόματη διανυσματοποίηση των υπολογισμών και την αποδοτική δρομολόγηση των εντολών επιβαρύνουν τον προγραμματιστή της εφαρμογής με το καθήκον της παραγωγής όσο το δυνατόν περισσότερο βελτιστοποιημένου κώδικα.\newline
\indent
Στο σχήμα~\ref{figure:fig62} παρουσιάζεται ο συνολικός αριθμός από εντολές που εκτελούνται και η τιμή της μετρικής \ac{CPI} για κάθε μία πλατφόρμα όταν όλοι οι διαθέσιμοι πόροι χρησιμοποιούνται. Θα πρέπει να σημειωθεί ότι η τιμή \ac{CPI} (περίπου \(0.0015\)) για την \ac{FPGA} είναι περίπου \(500\) φορές μικρότερη από την τιμή \ac{CPI} των άλλων δύο \acp{CPU}.\newline \indent
Για την καλύτερη κατανόηση της διαφορετικής επίδρασης που έχουν οι βελτιστοποιήσεις \ac{SIMD} στους επεξεργαστές \ac{CBEA} και \textsl{Core2 Quad} παρουσιάζουμε την λεπτομερή ανάλυση των χρόνων εκτέλεσης για κάθε συνάρτηση του κώδικα της εφαρμογής στο σχήμα~\ref{figure:fig63} (η βελτιστοποίηση \textsl{IMA} αναφέρεται στον επιμερισμό του κόστους της αντίστροφης απεικόνισης). Όπως παρατηρούμε, τα \acp{SPE} του επεξεργαστή \textsl{Cell} δαπανούν το \(75\%\) του χρόνου για την εκτέλεση της \textsl{αντίστροφης απεικόνισης} στη περίπτωση που εφαρμόζονται οι \textsl{CL} βελτιστοποιήσεις ενώ ο επεξεργαστής \textsl{Intel Core2 Quad} δαπανά μόνο το \(18\%\) του αντίστοιχου χρόνου εκτέλεσης. Τα ποσοστά αυτά μειώνονται σε \(15\%\) και \(0.3\%\) αντίστοιχα όταν εφαρμόζονται οι \textsl{FL} βελτιστοποιήσεις.\newline \indent
Αυτή η διαφορά στους χρόνους εκτέλεσης οφείλεται κυρίως στην υπερέχουσα απόδοση της μονάδας για εκτέλεση πράξεων κινητής υποδιαστολής της αρχιτεκτονικής \(x86\) και στην ικανότητα αυτής για εκτέλεση των στοιχειωδών συναρτήσεων στις σχέσεις \eqref{equation:eqtn23} στο υλικό, σε αντίθεση με τον επεξεργαστή \textsl{Cell} όπου η εκτέλεση αυτών των συναρτήσεων πραγματοποιείται μέσω βιβλιοθηκών λογισμικού. Σε αυτή την περίπτωση, η εφαρμογή βελτιστοποιήσεων που διευκολύνουν την εκτέλεση διανυσματικών πράξεων είναι ιδιαιτέρως σημαντική για την μείωση του χρόνου εκτέλεσης της εφαρμογής.
\begin{figure}[b]
\centering
\includegraphics[width=4.5in, height=3.5in]{Chapter6/figures/figure2.eps}
\caption{\label{figure:fig62}O συνολικός αριθμός εκτελούμενων εντολών και η τιμή του μεγέθους \textsl{CPI} για την βέλτιστη έκδοση του κώδικα της εφαρμογής.}
\end{figure}
Όπως αναφέρθηκε στην αρχή της παρούσας υποενότητας, η εκτέλεση του αλγορίθμου στην \ac{FPGA} είναι \textsl{pipelined} οπότε ο χρόνος εκτέλεσης είναι πάντα ίσος με τον χρόνο εκτέλεσης του πιο αργού τμήματος του αλγορίθμου, το οποίο είναι το σχήμα της \textsl{bicubic} παρεμβολής. Αυτό σημαίνει ότι στο σχήμα~\ref{figure:fig63} υπονοείται πως τα στάδια του \textsl{βαθυπερατού φίλτρου} και της \textsl{αντίστροφης απεικόνισης} τελειώνουν πιο νωρίς και αναμένουν για την περάτωση του σταδίου της παρεμβολής.

\subsection[6.2.2 Μελέτη Απόδοσης του Συστήματος Μνήμης]{Μελέτη Απόδοσης του Συστήματος Μνήμης}
\label{subsection:sub622}
\begin{figure}[b]
\centering
\includegraphics[width=4.5in, height=3.5in]{Chapter6/figures/figure3.eps}
\caption{Αναλυτική παράθεση του χρόνου εκτέλεσης κάθε συνάρτησης.}
\label{figure:fig63}
\end{figure}
\indent
Ένας σημαντικός περιοριστικός παράγοντας σε αρκετές \textsl{streaming} εφαρμογές είναι οι απαιτήσεις για το \textsl{off-chip} εύρος ζώνης. Το σχήμα~\ref{figure:fig64} απεικονίζει τον όγκο των δεδομένων ανά δευτερόλεπτο που μεταφέρονται από την κύρια μνήμη προς τον επεξεργαστή για κάθε μία από τις τρεις αρχιτεκτονικές.\newline \indent
Ο όγκος των δεδομένων είναι σχεδόν πλήρως προβλέψιμος. Για την δημιουργία και αποθήκευση στην κύρια μνήμη ενός \textsl{frame} μεγέθους \(900\ Kbytes\) συνολικά απαιτούνται περί τα \(4.98\ MBytes\) από δεδομένα εισόδου. Ο επιμερισμός του κόστους της \textsl{αντίστροφης απεικόνισης} σε διαφορετικά \textsl{frames} ενδέχεται να δημιουργήσει επιπλέον ανάγκη για την μεταφορά δεδομένων. Σε περίπτωση που η χωρητικότητα των \textsl{caches} εξωτερικού επιπέδου - δηλαδή η χωρητικότητα της \textsl{L2 cache} και η συνολική χωρητικότητα των \ac{LS}s του \ac{CBEA} - δεν επαρκούν για την αποθήκευση του \textsl{συνόλου εργασίας} για τον υπολογισμό του \textsl{frame}, οι κλασματικές συντεταγμένες, το μέγεθος των οποίων ανέρχεται σε επιπλέον \(1.32\ MB\) για κάθε \textsl{frame}, θα πρέπει να μεταφερθούν από την κύρια μνήμη.
\begin{figure}
\centering
\includegraphics[width=3.5in, height=2.5in]{Chapter6/figures/figure4.eps}
\caption{Μέσο \textsl{off-chip} εύρος ζώνης.}
\label{figure:fig64}
\end{figure}
\newline \indent
Η μέση τιμή του εύρους ζώνης που απαιτείται προσδιορίζεται κυρίως από τον χρόνο εκτέλεσης του αλγορίθμου διόρθωσης για κάθε \textsl{frame}. Η χειρότερη περίπτωση, τόσο σε όγκο δεδομένων που πρέπει να μεταφερθούν όσο και σε χρόνο εκτέλεσης της εφαρμογής, επιβάλλει την μεταφορά περισσοτέρων από \(350\ MBytes\) το δευτερόλεπτο. Επομένως, η πίεση που επιβάλλεται στο σύστημα της μνήμης είναι κατά πολύ χαμηλότερη από το εύρος ζώνης που προσφέρεται και στις τρεις αρχιτεκτονικές.
\newline \indent
Αυτή η παρατήρηση έρχεται σε αντίθεση με την κοινή πεποίθηση που θεωρεί την απόδοση της μνήμης \textsl{cache} ως τον κύριο περιοριστικό παράγοντα για εφαρμογές που ανήκουν στον \textsl{streaming} τομέα \cite{dynamiccache}. Ο όγκος των δεδομένων ανά εντολή που μεταφέρονται \textsl{off-chip} παρουσιάζεται στο σχήμα~\ref{figure:fig65}. Οι ρυθμοί αναφέρονται στην εκτέλεση της εφαρμογής με τον μέγιστο βαθμό παραλληλισμού που επιτρέπει η κάθε πλατφόρμα (\(4\) νήματα για τον επεξεργαστή \textsl{Core2 Quad} και \(8\) \acp{SPE} για τον επεξεργαστή \ac{CBEA}). Τα αποτελέσματα δεν μεταβάλλονται σε περίπτωση που χρησιμοποιηθούν λιγότερα νήματα ή \acp{SPE}.\newline \indent
Ο μέγιστος αριθμός των \textsl{bytes} που απαιτείται να μεταφερθούν από την κύρια μνήμη για κάθε εντολή ανέρχεται σε \(0.007\ bytes\). Αυτό αποδεικνύει τόσο την αποδοτικότητα της τεχνικής του \textsl{2D tiling} στην επαναχρησιμοποίηση των δεδομένων όσο και την \textsl{compute-intensive} φύση της εφαρμογής.\newline \indent
Συγκρινόμενος με τον ρυθμό για τον επεξεργαστή \ac{CBEA}, ο αντίστοιχος ρυθμός είναι κατά πολύ μικρότερος για τον επεξεργαστή \textsl{Core2 Quad} λόγω του συνολικού μεγέθους της \textsl{cache} στο τελευταίο επίπεδο της ιεραρχίας (\(6\ MB\) \textsl{L2 cache} έναντι \(2\ MB\) συνολικής μνήμης στις \ac{LS} των \acp{SPE}).\newline \indent
Για τον επεξεργαστή \ac{CBEA}, το σχήμα~\ref{figure:fig65} αποκαλύπτει ότι ο επιμερισμός του κόστους της \textsl{αντίστροφης απεικόνισης} έχει ως αποτέλεσμα την μεταφορά επιπλέον δεδομένων για κάθε εντολή που εκτελείται. Αυτό είναι αναμενόμενο καθώς οι \ac{LS} δεν επαρκούν για την αποθήκευση των δεδομένων εισόδου, εξόδου και των κλασματικών συντεταγμένων για κάθε \textsl{frame}. Αυτό έχει ως συνέπεια την συνεχή μεταφορά των κλασματικών συντεταγμένων από την κύρια μνήμη προς το κάθε \ac{SPE} για την διόρθωση του εκάστοτε \textsl{tile}. Το διάγραμμα εμφανίζει επίσης ότι ο κώδικας της εφαρμογής για τον \ac{CBEA} δεν είναι αρκετά αποδοτικός, όσον αφορά στην απόδοση της μνήμης, όταν εφαρμόζονται οι \textsl{FL} βελτιστοποιήσεις. Όμως, αυτό δεν είναι αληθές καθώς η παρατηρούμενη διαφορά μπορεί να αποδοθεί στην σημαντική μείωση του αριθμού των εντολών που συνεπάγεται η \textsl{διανυσματοποίηση των υπολογισμών} και η εφαρμογή της τεχνικής του \textsl{ξεδιπλώματος βρόχου}.\newline \indent
Θα πρέπει να αναφερθεί ότι η παρούσα ενότητα αναφέρεται στο εύρος ζώνης που απαιτεί η εφαρμογή \textsl{κατά μέσο όρο}. Ωστόσο, οι αιτήσεις για μεταφορά δεδομένων από την μνήμη τείνουν να πραγματοποιούνται κατά \textsl{ριπές} (\textsl{bursts}). Αυτό έχει ως αποτέλεσμα την δημιουργία παγωμάτων σε περίπτωση που το σύστημα μνήμης δεν έχει την ικανότητα να ικανοποιήσει αποδοτικά τις \textsl{ριπές} των αιτήσεων.
\begin{figure}
\centering
\includegraphics[width=3.5in, height=2.5in]{Chapter6/figures/figure5.eps}
\caption{Μεταφορές δεδομένων (σε \textsl{bytes}) ανά εντολή από την \textsl{off-chip} μνήμη.}
\label{figure:fig65}
\end{figure}

\subsection[6.2.3 Ανάλυση των Παγωμάτων]{Ανάλυση των Παγωμάτων}
\label{subsection:sub623}
\begin{figure}
\centering
\includegraphics[width=3.5in, height=2.5in]{Chapter6/figures/figure6.eps}
\caption{Αριθμός παγωμάτων (συνολικός αριθμός, παγώματα που σχετίζονται με τις διακλαδώσεις και παγώματα που σχετίζονται την μνήμη).}
\label{figure:fig66}
\end{figure}
\indent
Ο αριθμός των \textsl{παγωμάτων} (\textsl{stalls}) είναι μία μετρική που ποσοτικοποιεί τις καθυστερήσεις στην εκτέλεση της εφαρμογής που οφείλονται είτε σε έλλειψη πόρων είτε σε ανασχετικούς παράγοντες (\textsl{bottlenecks}) της αρχιτεκτονικής του συστήματος. Το σχήμα~\ref{figure:fig66} παρουσιάζει τον συνολικό αριθμό από παγώματα και τον αριθμό των παγωμάτων που προκαλούνται από δύο πολύ σημαντικούς παράγοντες - την αλληλεπίδραση της εφαρμογής με το σύστημα της μνήμης και την λανθασμένη πρόβλεψη διακλαδώσεων - για τις διαφορετικές βελτιστοποιήσεις που εφαρμόσθηκαν στους δύο επεξεργαστές. Ο αριθμός των παγωμάτων είναι συγκεντρωτικός (για όλα τα ενεργά πλαίσια εκτέλεσης - \textsl{execution contexts}) και αναφέρεται στην εκτέλεση της εφαρμογής με τον μέγιστο βαθμό παραλληλισμού που επιτρέπει η κάθε πλατφόρμα (\(4\) νήματα για τον επεξεργαστή \textsl{Core2 Quad} και \(8\) \acp{SPE} για τον επεξεργαστή \ac{CBEA}). Τα αποτελέσματα δεν μεταβάλλονται σε περίπτωση που χρησιμοποιηθούν λιγότερα πλαίσια εκτέλεσης.\newline \indent
Εύκολα παρατηρούμε ότι ο επεξεργαστής \ac{CBEA} είναι λιγότερο ανεκτικός στην εκτέλεση μη βέλτιστου κώδικα. Αυτό οφείλεται κυρίως στην αρκετά απλοποιημένη αρχιτεκτονική των \acp{SPE}, η οποία όμως συμβάλλει τα μέγιστα στην απόδοση του επεξεργαστή. Ο αριθμός των παγωμάτων του κώδικα όπου έχει εφαρμοσθεί το \textsl{tiling} είναι πολύ μεγαλύτερος για τον \ac{CBEA} σε σχέση με τον επεξεργαστή \textsl{Core2 Quad}. Ωστόσο, η εφαρμογή των \textsl{Fine-Level} βελτιστοποιήσεων έχει ως αποτέλεσμα την εξάλειψη του μεγαλύτερου αριθμού των παγωμάτων για τον επεξεργαστή \ac{CBEA}. Το ίδιο επίπεδο βελτιστοποιήσεων μειώνει περίπου κατά \(50\%\) τον αριθμό παγωμάτων στον επεξεργαστή \textsl{Core2 Quad}.\newline \indent
Ο εξελιγμένος μηχανισμός για την πρόβλεψη των διακλαδώσεων που ενσωματώνει ο επεξεργαστής \textsl{Intel} κατορθώνει να εξαλείψει τον αριθμό των παγωμάτων λόγω λανθασμένης πρόβλεψης διακλάδωσης. Στην αντίπερα όχθη, ο επεξεργαστής \ac{CBEA} δεν ενσωματώνει κάποιο μηχανισμό πρόβλεψης διακλάδωσης. Κάθε διακλάδωση προβλέπεται ως ψευδής\footnote{\small Η πρόβλεψη της διακλάδωσης δύναται να αλλαγεί στο επίπεδο του λογισμικού μέσω κατάλληλων \textsl{intrinsics} (\textsl{branch hints}) ή των αντίστοιχων εντολών \textsl{assembly}.} και σε περίπτωση λανθασμένης πρόβλεψης η καθυστέρηση είναι ίση με 20 κύκλους ρολογιού ενώ η τυπική καθυστέρηση των εντολών κυμαίνεται από \(2\) έως \(7\) εντολές. Η εκτέλεση του κώδικα επιβαρύνεται με αυτή την καθυστέρηση στην περίπτωση των διακλαδώσεων προς τα πίσω που υπάρχουν σε κάθε βρόχο. Οι \textsl{Fine-Level} βελτιστοποιήσεις και κυρίως η \textsl{διανυσματοποίηση των υπολογισμών} και το \textsl{ξεδίπλωμα βρόχου} μειώνουν τον αριθμό των επαναλήψεων των βρόχων και τον αριθμό των προς τα πίσω διακλαδώσεων. Αυτού του είδους τα παγώματα μειώνονται περαιτέρω μέσω των κατάλληλων εντολών λογισμικού (\textsl{software hinting}).\newline \indent
Εκτός από τα παγώματα λόγω της πρόβλεψης διακλαδώσεων, ένας ακόμη σημαντικός παράγοντας που συμβάλλει στον αριθμό των παγωμάτων είναι η αλληλεπίδραση μεταξύ του επεξεργαστή και της ιεραρχίας μνήμης. Πρότυπα προσπέλασης στην μνήμη που πραγματοποιούν αιτήσεις κατά \textsl{ριπές}, εισάγουν παγώματα είτε λόγω συγκρούσεων για την πρόσβαση στις διαθέσιμες θύρες της μνήμης είτε λόγω έλλειψης διαθέσιμων θέσεων στις ουρές του επεξεργαστή όπου αποθηκεύονται οι αιτήσεις για ανάγνωση ή εγγραφή στην μνήμη.\newline \indent 
Το πρόβλημα αυτό εντείνεται στον επεξεργαστή \ac{CBEA}, όπου η \ac{LS} διαθέτει μία μοναδική θύρα πρόσβασης. Οι αιτήσεις που δημιουργούνται από το \ac{SPE} ενδέχεται να συγκρούονται μεταξύ τους ή με άλλες εντολές που αιτούνται πρόσβαση στην μνήμη, όπως για παράδειγμα οι αιτήσεις του μηχανισμού \ac{DMA}. Για ακόμη μία φορά, παρατηρούμε ότι οι χαμηλού επιπέδου βελτιστοποιήσεις οδηγούν σε μείωση και αυτών των παγωμάτων. Η τεχνική του \textsl{ξεδιπλώματος βρόχου} επιτρέπει την δημιουργία πιο αποδοτικών δρομολογήσεων των εντολών καθώς υπάρχουν περισσότερες διαθέσιμες εντολές προς δρομολόγηση. Η μη αυτόματη δρομολόγηση των εντολών από τον προγραμματιστή, ιδίως στην περίπτωση του \ac{CBEA}, μειώνει περαιτέρω τις συγκρούσεις μεταξύ των εντολών σε περιπτώσεις που ο μεταγλωττιστής αποδεικνύεται αρκετά συντηρητικός.\newline \indent
Οι αιτήσεις του μηχανισμού \ac{DMA} για μεταφορές δεδομένων μεταξύ των \ac{LS}s και της κύριας μνήμης ενδέχεται να εισάγουν επιπλέον καθυστέρηση, η οποία οφείλεται είτε στον ανταγωνισμό για τα διαθέσιμα \textsl{κανάλια} (\textsl{channels}) του \ac{EIB} είτε στην καθυστέρηση που εισάγουν καθαυτές οι εντολές \ac{DMA}. Η τεχνική του \textsl{double-buffering} αποδεικνύεται αρκετά αποδοτική στην επικάλυψη αυτών των καθυστερήσεων με την εκτέλεση υπολογισμών. Ο συνολικός αριθμός των παγωμάτων που οφείλεται στις αιτήσεις \ac{DMA} είναι περιορισμένος και, στην χειρότερη περίπτωση, ανέρχεται σε \(600\) κύκλους.

\subsection[6.2.4 Κόστος Υλοποίησης]{Κόστος Υλοποίησης}
\label{subsection:sub624}
\indent
Το κόστος που απαιτείται για την υλοποίηση της εφαρμογής είναι ένας σημαντικός παράγοντας που πρέπει να ληφθεί υπόψη κατά την χρήση μίας νέας πλατφόρμας για την ανάπτυξη εφαρμογών. Μία πτυχή στην σύγκριση των προγραμματιστικών μοντέλων για τις τρεις χρησιμοποιούμενες αρχιτεκτονικές είναι η προσπάθεια που πρέπει να καταβληθεί από τον προγραμματιστή της εφαρμογής. Καθώς είναι αρκετά δύσκολο να υπολογισθούν ακριβή στατιστικά για τον χρόνο που απαιτείται για την ανάπτυξη μίας εφαρμογής, χρησιμοποιούμε το μέγεθος \textsl{Lines-of-Code} (\textsl{LOC}) ως την κύρια μετρική για την ποσοτικοποίηση της προγραμματιστικής προσπάθειας.\newline \indent
Ο αρχικός κώδικας της εφαρμογής στην γλώσσα προγραμματισμού \textsl{C}, όπου χρησιμοποιείται μόνο ένα νήμα εκτέλεσης, αποτελείται από \(800\) γραμμές πηγαίου κώδικα (\textsl{LOC}). Ο πλήρως βελτιστοποιημένος κώδικας της εφαρμογής για τον επεξεργαστή \ac{CBEA} απαιτεί \(1500\) επιπλέον γραμμές κώδικα ενώ ο αντίστοιχος κώδικας για τον επεξεργαστή \textsl{x86} απαιτεί μόνο \(500\) επιπλέον γραμμές πηγαίου κώδικα. Η περιγραφή του \ac{sDFG} για την \ac{FPGA} αποτελείται από \(800\) γραμμές κώδικα που ομοιάζει με εντολές \textsl{assembly}. Συν τοις άλλοις, η υλοποίηση της εφαρμογής στην \ac{FPGA} απαιτεί πολλαπλές και αρκετά χρονοβόρες επαναλήψεις για τις διαδικασίες της \textsl{σύνθεσης} (\textsl{synthesis}) και του \textsl{place \& route}, οι οποίες θα πρέπει να ληφθούν υπόψη στο συνολικό κόστος της ανάπτυξης της εφαρμογής.\newline \indent
Βασιζόμενοι σε αυτές τις παρατηρήσεις, η αρχιτεκτονική του επεξεργαστή \textsl{Core2 Quad} προσφέρει ένα καλύτερο μοντέλο προγραμματισμού ενώ ο επεξεργαστής \ac{CBEA} έχει ένα σχετικό πλεονέκτημα έναντι της \ac{FPGA}. Παρόλα αυτά, βασιζόμενοι στον συνολικό χρόνο ανάπτυξης της εφαρμογής,  πιστεύουμε ότι η σχεδίαση και η υλοποίηση αναδιατασσόμενων συστημάτων με χρήση γλωσσών υψηλού επιπέδου θα είναι αρκετά ανταγωνιστική σε σχέση με τα \textsl{manycore} και τα \textsl{multicore} συστήματα εάν το κόστος υλοποίησης για την εκάστοτε εφαρμογή ληφθεί υπόψη.


